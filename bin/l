#!/bin/bash

fallback=0
if (($# >= 1)) && [[ "${1:0:1}" == "-" ]]; then
	fallback=1
elif cut --help | grep -q -- -z; then
	cut_z_chars() {
		cut -z -c"$1" "$2"
	}
	cut_z_chars_since() {
		cut -z -c"$1"- "$2"
	}
elif awk --version | grep -q 'GNU'; then
	cut_z_chars() {
		awk -v N="$1" 'BEGIN{ RS="\0"; ORS="\0"; } {print substr($0,N,1)}' "$2"
	}
	cut_z_chars_since() {
		awk -v N="$1" 'BEGIN{ RS="\0"; ORS="\0"; } {print substr($0,N)}' "$2"
	}
else
	fallback=1
fi

if ((fallback)); then
	# In such case we do not have our requirements met, we fall back to the good old ls version
	exec ls -alFh --color=auto --group-directories-first "$@"
fi

fatal() {
	echo "l: error: $*" >&2
	exit 1
}

_ls=(
	ls -aldFhU --color=auto
)

findargs=(
	-mindepth 1 -maxdepth 1 '('
	'(' -name '.*' '('
			        '(' -type d -printf "A"
			')' -o  '(' -type l -printf "B"
			')' -o  '(' -type p -printf "C"
			')' -o  '(' -type s -printf "D"
			')' -o  '(' -type b -printf "E"
			')' -o  '(' -type c -printf "F"
			')' -o  '(' -type f -printf "G"
			')' -o              -printf "H"
	')' ')' -o      '(' -type d -printf "a"
			')' -o  '(' -type l -printf "b"
			')' -o  '(' -type p -printf "c"
			')' -o  '(' -type s -printf "d"
			')' -o  '(' -type b -printf "e"
			')' -o  '(' -type c -printf "f"
			')' -o  '(' -type f -printf "g"
			')' -o              -printf "h"
	')' -printf "%P\0"
)

dodirlist() {
	if ! cd "$1"; then
		fatal "Could not change directory: $1"
	fi
	find . "${findargs[@]}" | sort -z > "$tmpf" ||:
	cut_z_chars 1 "$tmpf" | tr '\0' '\n' | awk '
		#BEGIN{
		#	lower["a"]; lower["b"]; lower["c"]; lower["d"]; lower["e"]; lower["f"]; lower["g"];
		#	upper["A"]; upper["B"]; upper["C"]; upper["D"]; upper["E"]; upper["F"]; upper["G"];
		#}
		#$1 in upper { hidden += $1 }
		$1 == "a" || $1 == "A" { dirs++;   next }
		$1 == "g" || $1 == "G" { files++;  next }
		#$1 == "b" || $1 == "B" { links++   }
		#$1 == "c" || $1 == "C" { pipes++   }
		#$1 == "d" || $1 == "D" { sockets++ }
		#$1 == "e" || $1 == "E" { blocks++  }
		#$1 == "f" || $1 == "F" { chars++   }
		{ other++ }
		END{
			printf("total %d directories, %d files, %d other\n", dirs, files, other)
		}'
	if ! {
			printf "%s\0" . ..
			cut_z_chars_since 2 "$tmpf"
		} | xargs -0 -r "${_ls[@]}"
	then
		fatal "ls failed"
	fi
	if ! cd - >/dev/null; then
		fatal "Could not change directory back from: $1"
	fi
}

dols() {
	if [[ -d "$1" ]]; then
		printf "%q:\n" "$1"
		dodirlist "$1"
	else
		if ! "${_ls[@]}" "$1"; then
			fatal "ls failed"
		fi
	fi
}

tmpf=$(mktemp)
trap 'rm "$tmpf"' EXIT

if (($# == 0)); then
	dodirlist .
else
	dols "$1"
	shift
	for i in "$@"; do
		echo
		dols "$i"
	done
fi


