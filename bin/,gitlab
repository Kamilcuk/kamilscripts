#!/bin/bash
set -euo pipefail
shopt -s extglob nullglob

g_refresh_gitlab_vars() {
	GITLAB_API_URL="https://${GITLAB_URL}/api/v4/"
}

g_use_gitlab2() {
	GITLAB_URL=${GITLAB2_URL:-${GITLAB_URL}}
	GITLAB_TOKEN=${GITLAB2_TOKEN:-${GITLAB_TOKEN}}
	g_refresh_gitlab_vars
}

run_curl() {
	local cmd
	cmd=(curl -sS -iL --header "Authorization: *****" "$@")
	L_info + "${cmd[@]}"
	if [[ -z "${GITLAB_TOKEN:-}" ]]; then
		L_fatal "GITLAB_TOKEN variable is empty!"
	fi
	cmd=(curl -sSLH "Authorization: Bearer ${GITLAB_TOKEN}" "$@")
	if "$DEBUG"; then
		L_log + "${cmd[@]@Q}"
	fi
	"${cmd[@]}" || true
}

hdr_get_data() { sed '/^\r$/,$!d'; }
hdr_get_header() { sed '1,/^\r$/!d'; }
hdr_get_link() {
	local tmp
	tmp=$(hdr_get_header | sed -n 's/^link:.* <\([^>]*\)>; rel="next".*/\1/p')
	printf "%s" "$tmp"
	[[ -n "$tmp" ]]
}

get_paginated() {
	local tmp acc
	acc=""
	while true; do
		tmp=$(run_curl -i "$@")
		acc+="$(hdr_get_data <<<"$tmp")"
		if ! link=$(<<<"$tmp" hdr_get_link) || [[ -z "$link" ]]; then break; fi
		set -- "$link"
	done
	<<<"$acc" jq -s add
}

###############################################################################`

# shellcheck disable=2145
C_GETRAW() {
	local path
	path="${GITLAB_API_URL}/$1"
	shift
	path=${path//\/+(\/)/\/}
	run_curl "$path" "$@"
	echo
}

C_GET() {
	local path tmp
	path="${GITLAB_API_URL}/$path"
	shift
	path=${path//\/+(\/)/\/}
	get_paginated "$path?pagination=keyset&per_page=100&order_by=id&sort=asc" "$@"
}

# shellcheck disable=2145
C_POST() {
	run_curl -X POST "${GITLAB_API_URL}/$@"
}

C_get_groups() {
	C_GET /groups
}

C_get_group_from_name() {
	C_get_groups | jq --arg name "$1" '.[] | select(.name == $name)'
}

C_list_projects_in_group() {
	if (($# != 1)); then L_fatal "Need one argument - group id"; fi
	C_GET "/groups/$1/projects"
}

C_list_projects_in_group_name() {
	if (($# != 1)); then L_fatal "Need one argument - group name"; fi
	C_list_projects_in_group "$(C_get_group_from_name "$1" | jq -r .id)"
}

C_project_get_link_to_CI_CD_Settings() {
	tmp=$(C_GET "/projects/$1" | jq -r .web_url)
	echo "$tmp/-/settings/ci_cd"
}

C_list_links_to_CI_CD_Settings_of_all_projects_in_group_name() {
	C_list_projects_in_group_name "$1" |
		jq '.[].id' |
		while IFS= read -r line; do
			C_project_get_link_to_CI_CD_Settings "$line"
		done
}

C_ci_lint() {
	if (($# != 1)); then
		if [[ -r   ./.gitlab-ci.yml ]]; then
			set -- ./.gitlab-ci.yml
		else
			L_fatal "Need one argument"
		fi
	fi
	if (($# == 0)); then L_usage; L_fatal "Needs file as argument"; fi

	local path url status data
	url="ci/lint"
	if C_git_project_namespace_path path; then
		url="projects/$path/ci/lint"
	fi

	local errors i data valid
	errors=0
	for i in "$@"; do
		# https://about.gitlab.com/blog/2021/04/21/devops-workflows-json-format-jq-ci-cd-lint/
		data=$(jq --null-input --arg yaml "$(<"$i")" '.content=$yaml')
		tmp=$(C_GETRAW "$url?include_merged_yaml=true" \
				--header 'Content-Type: application/json' \
				--data @<(cat <<<"$data")
		)
		tmp=$(jq <<<"$tmp")
		if ! valid=$(jq -r '.valid' <<<"$tmp") || 
				[[ "$valid" != "true" ]]; then
			cat <<<"$tmp"
			((errors++)) ||:
		else
			jq -r '.merged_yaml' <<<"$tmp"
			L_log "ALL FINE!"
		fi
	done
	L_trap_err_disable
	exit $((!!errors))
}

C_list_current_user() {
	C_GET /user
}

C_get_current_user_id() {
	C_GET /user | jq .id
}

# shellcheck disable=2001
g_urlescape() {
	sed 's~/~%2F~g' <<<"$*"
}

C_search_projects() {
	local search
	search=$(g_urlescape "$1")
	shift
	C_GETRAW "/search?scope=projects&search=$search" "$@"
}

C_search_project_id() {
	C_search_projects "$@" | jq -r '.[] | "\(.path_with_namespace)\t\(.id)"'
}

C_search_project_id_first() {
	L_trap_err_disable
	C_search_project_id "$@" | {
		IFS=$'\t'
		if ! read -r path id; then
			L_warn "Could not find any projects"
			exit 1
		fi
		if ! read -r path2 id2; then
			printf "%s\n" "$id"
		else
			L_warn "Multiple projects found for this search query: $1"
			printf "%s\n" "$path" "$id"
			printf "%s\t%s\n" "$path2" "$id2"
			cat
			exit 1
		fi
	}
}

C_git_project_namespace_path() {
	local _tmp
	if _tmp=$(git remote -v get-url origin 2>/dev/null); then
		_tmp=$(sed -E 's~(http|ssh)://~~; s~git@~~; s~[:/]~ ~; s/\.[^\.]*$//; s~/~%2F~' <<<"$_tmp")
		local _url _path
		if read -r _url _path <<<"$_tmp"; then
			if [[ "$_url" != "$GITLAB_URL" && "$_url" == "$GITLAB2_URL" ]]; then
				g_use_gitlab2
			fi
		fi
		printf -v "$1" "%s" "$_path"
		return 0;
	fi
	return 1;
}

C_get_project_id() {
	local path
	if C_git_project_namespace_path path; then
		C_GETRAW "projects/$path" | jq '.id'
		exit
	fi
	C_search_project_id_first "$@"
}

C_get_project_tags() {
	local id
	id=$(C_get_project_id "$@")
	C_GETRAW "/projects/$id/repository/tags"
}

C_repo_create() {
	if (($# < 1)); then L_fatal "Argument needed"; fi
	args=$(getopt -n "$L_name" -o d -l description:,public,private,internal,enable-issues::,enable-wiki:: -- "$@")
	eval set -- "$args"
	mode=
	issues=false
	wiki=false
	while (($#)); do
		case "$1" in
		-d|--description) description=$2; shift; ;;
		--private|--public|--internal) mode=${1//--/}; ;;
		--enable-issues) issues=${2:-true}; shift; ;;
		--enable-wiki) wiki=${2:-true}; shift; ;;
		--) shift; break; ;;
		*) L_fatal "Internal error"; ;;
		esac
		shift;
	done
	if [[ -z "$mode" ]]; then L_fatal "--public --private or --internal argument needed"; fi

	C_POST /projects "$@"
}

###############################################################################

: "${GITLAB_URL:="gitlab.com"}"
: "${GITLAB_TOKEN:=}"
: "${DEBUG:=false}"
g_refresh_gitlab_vars

. ,lib_lib -q 

args=$(getopt -n "$L_name" -o +2 -l bash-completion -- "$@")
eval set -- "$args"
while (($#)); do
	case "$1" in
	-2) g_use_gitlab2; ;;
	--bash-completion) break; ;;
	--) shift; break;
	esac
	shift
done

. ,lib_lib C_ "$@"
