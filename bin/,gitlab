#!/bin/bash
set -euo pipefail
shopt -s extglob nullglob

g_refresh_gitlab_vars() {
	GITLAB_API_URL="https://${GITLAB_URL}/api/v4/"
}

g_use_gitlab2() {
	GITLAB_URL=${GITLAB2_URL:-${GITLAB_URL}}
	GITLAB_TOKEN=${GITLAB2_TOKEN:-${GITLAB_TOKEN}}
	g_refresh_gitlab_vars
}

run_curl() {
	local cmd
	cmd=(curl -sS -iL --header "Authorization:---" "$@")
	L_info "+$(printf " %q" "${cmd[@]}")"
	if [[ -z "${GITLAB_TOKEN:-}" ]]; then
		L_fatal "GITLAB_TOKEN variable is empty!"
	fi
	cmd=(curl -sSLH "Authorization: Bearer ${GITLAB_TOKEN}" "$@")
	if "$DEBUG"; then
		L_log + "${cmd[@]@Q}"
	fi
	"${cmd[@]}" || true
}

hdr_get_data() { sed '/^\r$/,$!d'; }
hdr_get_header() { sed '1,/^\r$/!d'; }
hdr_get_link() {
	local tmp
	tmp=$(hdr_get_header | sed -n 's/^link:.* <\([^>]*\)>; rel="next".*/\1/p')
	printf "%s" "$tmp"
	[[ -n "$tmp" ]]
}

get_paginated() {
	local tmp acc
	acc=""
	while true; do
		tmp=$(run_curl -i "$@")
		acc+="$(hdr_get_data <<<"$tmp")"
		if ! link=$(<<<"$tmp" hdr_get_link) || [[ -z "$link" ]]; then break; fi
		set -- "$link"
	done
	<<<"$acc" jq -s add
}

###############################################################################`

get_parse_args() {
	local path tmp
	path="$1"
	shift
	# Replaces ////// by /
	path=${path//\/+(\/)/\/}
	# Add gitlab-api-url so that remove multiple /
	path="${GITLAB_API_URL%%/}/${path##/}"
	# args is global
	args=("$path" "$@")
}

# shellcheck disable=2145
C_GETRAW() {
	local args ; get_parse_args "$@"
	run_curl "${args[@]}"
	echo
}

C_GET() {
	local args ; get_parse_args "$@"
	get_paginated "${args[0]}?pagination=keyset&per_page=100&order_by=id&sort=asc" "${args[@]:1}"
}

# shellcheck disable=2145
C_POST() {
	local args ; get_parse_args "$@"
	run_curl -X POST "${args[@]}"
}

C_get_groups() {
	C_GET /groups
}

C_get_group_from_name() {
	C_get_groups | jq --arg name "$1" '.[] | select(.name == $name)'
}

C_get_group_id_from_name() {
	C_get_group_from_name "$@" | jq -r '.id'
}

C_list_projects_in_group() {
	if (($# != 1)); then L_fatal "Need one argument - group id"; fi
	C_GET "/groups/$1/projects"
}

C_list_projects_in_group_name() {
	if (($# != 1)); then L_fatal "Need one argument - group name"; fi
	C_list_projects_in_group "$(C_get_group_from_name "$1" | jq -r .id)"
}

C_project_get_link_to_CI_CD_Settings() {
	local tmp
	tmp=$(get_project_info_cached | jq -r .web_url)
	echo "$tmp/-/settings/ci_cd"
}

C_list_links_to_CI_CD_Settings_of_all_projects_in_group_name() {
	C_list_projects_in_group_name "$1" |
		jq '.[].id' |
		while IFS= read -r line; do
			C_project_get_link_to_CI_CD_Settings "$line"
		done
}

# shellcheck disable=2001
C_ci_lint() {
	if (($# != 1)); then
		if [[ -r   ./.gitlab-ci.yml ]]; then
			set -- ./.gitlab-ci.yml
		else
			L_fatal "Need one argument"
		fi
	fi
	if (($# == 0)); then L_usage; L_fatal "Needs file as argument"; fi

	local path url data
	url="ci/lint"
	if path=$(C_get_project_namespace_path); then
		url="projects/$path/ci/lint"
	fi

	local errors i data l_valid l_warnings l_errors l_mergedyaml
	errors=0
	for i in "$@"; do
		# https://about.gitlab.com/blog/2021/04/21/devops-workflows-json-format-jq-ci-cd-lint/
		data=$(jq --null-input --arg yaml "$(<"$i")" '.content=$yaml')
		tmp=$(C_GETRAW "$url?include_merged_yaml=true" \
				--header 'Content-Type: application/json' \
				--data @<(cat <<<"$data")
		)
		tmp=$(jq <<<"$tmp")
		if ! l_valid=$(jq -r '.valid' <<<"$tmp") || [[ "$l_valid" != "true" ]]; then
			if ! l_mergedyaml=$(jq -r '.merged_yaml' <<<"$tmp"); then
				cat <<<"$tmp"
			else
				cat <<<"$l_mergedyaml"
				echo
				if l_warnings=$(jq -r '.warnings[]' <<<"$tmp") && [[ -n "$l_warnings" ]]; then
					echo "${L_YELLOW}""Warnings:"
					sed 's/^/\t/; $s/$/'"${L_RESET}"'/' <<<"$l_warnings"
				fi
				if l_errors=$(jq -r '.errors[]' <<<"$tmp") && [[ -n "$l_errors" ]]; then
					echo "${L_RED}""Errors:"
					sed 's/^/\t/; $s/$/'"${L_RESET}"'/' <<<"$l_errors"
				fi
			fi
			((errors++)) ||:
		else
			jq -r '.merged_yaml' <<<"$tmp"
			L_log "ALL FINE!"
		fi
	done
	L_trap_err_disable
	return "$((!!errors))"
}

C_list_current_user() {
	C_GET /user
}

C_get_current_user_id() {
	C_GET /user | jq .id
}

# shellcheck disable=2001
g_urlescape() {
	sed 's~/~%2F~g' <<<"$*"
}

C_search_projects() {
	local search
	search=$(g_urlescape "$1")
	shift
	C_GETRAW "/search?scope=projects&search=$search" "$@"
}

C_search_project_id() {
	C_search_projects "$@" | jq -r '.[] | "\(.path_with_namespace)\t\(.id)"'
}

C_search_project_id_first() {
	L_trap_err_disable
	C_search_project_id "$@" | {
		IFS=$'\t'
		if ! read -r path id; then
			L_warn "Could not find any projects"
			exit 1
		fi
		if ! read -r path2 id2; then
			printf "%s\n" "$id"
		else
			L_warn "Multiple projects found for this search query: $1"
			printf "%s\n" "$path" "$id"
			printf "%s\t%s\n" "$path2" "$id2"
			cat
			exit 1
		fi
	}
}

project_info_cachef=/tmp/,gitlab-projinfocache.$$.json
get_project_info_cached() {
	if [[ ! -e "$project_info_cachef" ]]; then
		tmp=$(C_get_project_namespace_path)
		C_GETRAW "projects/$tmp" > "$project_info_cachef"
	fi
	cat "$project_info_cachef"
}

C_get_project_info_cached() {
	get_project_info_cached
}

C_get_project_namespace_path() {
	git remote -v get-url origin 2>/dev/null |
	sed '
		# remove domain name from url
		s~^\([^:]*://\)\?\([^@]*@\)\?[^:/]*[:/]~~
		# Remove trialing git
		s/\.git$//;
		# replace slashes
		s~/~%2F~
	'
}

C_get_project_name() {
	get_project_info_cached | jq '.name'
}

C_get_project_id() {
	local tmp
	if tmp=$(get_project_info_cached); then
		jq '.id' <<<"$tmp"
		exit
	fi
	C_search_project_id_first "$@"
}

C_get_project_tags() {
	local id
	id=$(C_get_project_id "$@")
	C_GETRAW "/projects/$id/repository/tags"
}

C_create_project() {
	addarg() {
		local tmp
		#tmp="$(g_urlescape "$*")"
		tmp="$*"
		curlopts+=(-d "$tmp")
	}
	usage() {
		n=",gitlab create_project"
		cat <<EOF
Usage: $n [options] 

Options:
	--nowiki
	--name <str>
	--path <str>
	--description <str>
	--namespace <str>
 	-a --add <opt>=<val>
			Takes any option from:
			https://docs.gitlab.com/ee/api/projects.html#create-project

Example:
	$n --namespace Kamcuk --name somelib

EOF
	exit 0
	}
	#
	if (($# == 0)); then usage; fi;
	args=$(getopt -n "$L_name" \
		-o a:h \
		-l nowiki,add:,name:,path:,description:,namespace: -- "$@")
	eval set -- "$args"
	curlopts=()
	while (($#)); do
		case "$1" in
		-h) usage; ;;
		--nowiki) addarg "wiki_access_level=disabled" ;;
		--add|--name|--path|--description)
			addarg "${1#--}=$2"
			shift
			;;
		--namespace)
			if ! id=$(C_get_group_id_from_name "$2") || [[ -z "$id" ]]; then
				L_fatal "Could not get id for project $2"
			fi
			addarg namespace_id="$id"
			shift
			;;
		--) shift; break; ;;
		*) L_fatal "Internal error: $v"; ;;
		esac
		shift;
	done
	if (($#)); then usage; fi;

	if ! tmp=$(C_POST /projects "${curlopts[@]}"); then
		jq <<<"$tmp"
		L_fatal "Failure"
		exit 1
	fi
	jq <<<"$tmp"
	echo "SUCCESS"
}

C_my_create_project() {
	C_create_project --namespace Kamcuk --name "$@"
}

C_gitlabciyml-cached() {
	local namespacepath size
	namespacepath=$(C_get_project_namespace_path)
	g_cache="/tmp/run-gitlab-ci_${namespacepath}_.gitlab-ci.yml"
	if
		[[ ! -e "$g_cache" ]] ||
		[[ .gitlab-ci.yml -nt "$g_cache" ]] ||
		(
			[[ -e "$g_cache" ]] &&
			size=$(stat -c %s "$g_cache") &&
			((size < 10))
		)
	then
		L_log "Refreshing cache at $g_cache"
		if ! C_ci_lint > "$g_cache"; then
			rm "$g_cache"
			L_fatal ".gitlab-ci.yml is invalid"
		fi
	else
		L_log "Using cache at $g_cache"
	fi
	cat "$g_cache"
}

C_gitlabciyml-list-jobs() {
	C_gitlabciyml-cached |
		yq -r 'to_entries[] | select(.value.restricted|not) | .key'
}

C_run-gitlabci() {
	#
	L_name="$L_NAME gitlabci-run"
	l_usage() {
		cat <<EOF
Usage: $L_name <job to run>
EOF
	}
	local args debugme
	args=$(getopt -n "$L_name" -o hd -- "$@")
	debugme=0
	eval "set -- $args"
	while (($#)); do
		case "$1" in
		-h) l_usage; ;;
		-d) debugme=1; ;;
		--) shift; break; ;;
		*) L_fatal "Internal error when parsing args"; ;;
		esac
		shift
	done
	if (($# == 0)); then l_usage; exit 1; fi
	if (($# > 1)); then L_fatal "Too many arguments"; fi
	local job
	job="$1"
	#
	local gitlabciyml
	gitlabciyml="$(C_gitlabciyml-cached)"
	#
	local jobdef
	# shellcheck disable=2016
	if ! jobdef=$(<<<"$gitlabciyml" yq --arg job "$job" '.[$job]'); then
		L_fatal "There is no job named $job in .gitlab-ci.yml"
	fi
	if ((debugme)); then
		echo "--- job definition: ---"
		yq -y <<<"$jobdef" | sed 's/^/  /'
		echo
	fi
	#
	local image
	image=$(jq -r .image <<<"$jobdef")
	#
	local g_toexe
	g_toexe=""
	local green reset cyan
	green=${L_GREEN//$'\E'/'\e'}
	reset=${L_RESET//$'\E'/'\e'}
	cyan=${L_CYAN//$'\E'/'\e'}
	toexeadd() {
		g_toexe+="$*"$'\n'
	}
	toexe_cmsg() {
		toexeadd "printf" "'$1%s$reset\n'" "$(printf "%q" "$ ${2%%$'\n'*}")"
	}
	toexenotify() {
		toexe_cmsg "$green" "$@"
	}
	toexenotifycyan() {
		toexe_cmsg "$cyan" "$@"
	}
	toexeadd "set -euo pipefail"
	toexenotifycyan "Setuping variables in $image ..."
	#
	# Add CI_* variables that need to be generated. Mostly TODO
	# shellcheck disable=2034,2086
	gen_ci() {
		unset ${!CI_*} ||:
		echo 'CI=true'

		CI_COMMIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
		CI_COMMIT_AUTHOR="$(git log -1 --pretty='%an') <$(git log -1 --pretty='%ae')>"
		gs() {
			local tmp
			tmp="$(git log "${3:--1}" --pretty="$2")"
			printf -v "$1" "%s" "$tmp"
		}
		gs CI_COMMIT_DESCRIPTION %B
		gs CI_COMMIT_MESSAGE %B
		gs CI_COMMIT_REF_NAME %S
		gs CI_COMMIT_SHA %H
		gs CI_COMMIT_SHORT_SHA %h
		CI_COMMIT_BEFORE_SHA=$(git log -2 --pretty=%H | tail -n1)
		gs CI_COMMIT_TIMESTAMP %aI

		CI_DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
		CI_JOB_IMAGE="$image"
		CI_JOB_NAME="$job"
		CI_JOB_STAGE="$(jq -r '.stage // "test"' <<<"$jobdef")"
		CI_JOB_STARTED_AT=$(date -Is)
		CI_JOB_ID=$SRANDOM

		CI_PIPELINE_ID=$SRANDOM
		CI_PIPELINE_SOURCE=trigger
		CI_PIPELINE_TRIGGERED=true
		CI_PIPELINE_CREATED_AT=$CI_JOB_STARTED_AT

		# Make CI_PROJECT_DIR relative to ~
		echo "CI_PROJECT_DIR=~/$(printf "%q" CI_PROJECT_NAME)"
		sinfo() {
			local tmp
			tmp=$(get_project_info_cached | jq -r "$2")
			printf -v "$1" "%s" "$tmp"
		}
		sinfo CI_PROJECT_ID .id
		sinfo CI_PROJECT_NAME '.name'
		sinfo CI_PROJECT_NAMESPACE '.namespace.path'
		sinfo CI_PROJECT_PATH '.path_with_namespace'
		CI_PROJECT_TITLE=$CI_PROJECT_NAME
		sinfo CI_PROJECT_URL '.web_url'
		sinfo CI_PROJECT_VISIBILITY '.visibility'

		CI_RUNNER_ID=$SRANDOM
		CI_SERVER_NAME=$HOSTNAME

		for i in ${!CI_*}; do
			echo "$i=$(printf "%q" "${!i}")"
		done
	}
	tmp=$(gen_ci)
	toexeadd "$tmp"
	#
	# Add variables from variables: from yaml.
	toexeadd '# variables from job:'
	local variablesdef key value
	variablesdef=$(jq -r '[ .variables // [] | to_entries[] | .key, .value ] | .[] | @base64' <<<"$jobdef")
	while IFS= read -r key && IFS= read -r value; do
		key=$(base64 -d <<<"$key")
		value=$(base64 -d <<<"$value")
		value=$(printf "%q" "$value")
		toexeadd "$key=$value"
	done <<<"$variablesdef"
	#
	# Copy the directory with the project to CI_PROJECT_DIR
	toexenotifycyan "Cloning project..."
	_setup() {
		cp -a /orig "$CI_PROJECT_DIR"
		cd "$CI_PROJECT_DIR"
	}
	toexeadd "$(declare -f _setup); _setup"
	#
	execscript() {
		local part script line
		part=$1
		script=$(jq -r ".$part // [] | .[] | @base64" <<<"$jobdef") 
		if [[ -z "$script" ]]; then
			if [[ "$part" = "script" ]]; then
				L_fatal "There is no script: section defined for $job"
			fi
			return
		fi
		toexenotifycyan "Executing $part:"
		while IFS= read -r line; do
			if [[ -z "$line" ]]; then continue; fi
			line=$(base64 -d <<<"$line")
			toexenotify "$line"
			toexeadd "$line"
		done <<<"$script"
		toexeadd 'CI_JOB_STATUS=$?'
	}
	execscript "before_script"
	execscript "script"
	execscript "after_script"
	# Handle services:
	local services servicesdef
	if
		servicesdef=$(jq -r '.services // [] | .[] | @base64' <<<"$jobdef") &&
		[[ -n "$servicesdef" ]]
	then
		while IFS= read -r line; do
			if [[ -z "$line" ]]; then conitnue; fi
			line=$(base64 -d <<<"$line")
			services+=("$line")
		done <<<"$servicesdef"
	fi

	# Run it all in docker-compose in temporary directory
	(
		tmpd=$(mktemp --tmpdir -d ,gitlab-run-gitlabci-XXXXXXXXX)
		trap_exit() {
			set +euo pipefail
			L_log "${L_CYAN}Exit cleanup${L_RESET}"
			if [[ -d "$tmpd" ]]; then
				docker-compose down -v 2>/dev/null ||:
				cd /
				rm -r "$tmpd"
			fi
		}
		trap trap_exit EXIT
		L_log "${L_CYAN}Setuping docker-compose in $tmpd ...${L_RESET}"
		#
		dockercompose=$(jq \
			--arg image "$image" \
			--arg PWD "$PWD" \
			-n '{
				version: "3",
				services: { work: { image: $image,
					volumes: [ "./work.sh:/work.sh:ro", ($PWD + ":/orig:ro") ],
					command: [ "sh", "-c",
						"sleep 1 && if hash bash 2>/dev/null; then bash ./work.sh; else sh ./work.sh; fi"
				] } } }'
		)
		for srv in "${services[@]}"; do
			dockercompose=$(<<<"$dockercompose" jq \
				--arg srv "${srv%%[:-]*}" --arg image "$srv" '
				.services += { ($srv): { image: $image, privileged: true, volumes: ["/certs"]
					#, logging: { driver: "none" }
				} } |
				.services.work.volumes_from += [ ("service:" + $srv + ":ro") ] |
				.services.work.links += [ $srv ] |
				.services.work.depends_on += [ $srv ]
			')
		done
		#
		cd "$tmpd"
		yq -y <<<"$dockercompose" > ./docker-compose.yml
		if ! docker-compose config; then
			cat docker-compose.yml
			L_fatal "Internal error: generated invalid docker-compose"
		fi
		cat <<<"$g_toexe" > ./work.sh
		if ((debugme)); then
			echo "--- to execute: ---"
			sed 's/^/  /' ./work.sh
			echo
		fi
		#
		local ret
		ret=0
		for srv in "${services[@]}"; do
			L_run docker-compose up -d "${srv%%[:-]*}"
		done
		L_run docker-compose run work || ret=$?
		L_log "${L_CYAN}Cleanup${L_RESET}"
		L_run docker-compose down -v ||:
		cd /
		rm -r "$tmpd"
		if ((ret == 0)); then
			L_log "${L_GREEN}job succeeded${L_RESET}"
		else
			L_log "${L_RED}${L_BOLD}ERROR: Job failed: exit code $ret${L_RESET}"
		fi
	)
	exit

	#
	#
}

###############################################################################

trap 'rm -f "$project_info_cachef"' EXIT

: "${GITLAB_URL:="gitlab.com"}"
: "${GITLAB_TOKEN:=}"
: "${DEBUG:=false}"
# automatically use proper gitlab setting if url matches
if tmp=$(git remote -v get-url origin 2>/dev/null); then
	if [[ "$tmp" != *"$GITLAB_URL"* && "$tmp" == *"$GITLAB2_URL"* ]]; then
		g_use_gitlab2
	fi
fi
#
g_refresh_gitlab_vars

. ,lib_lib -q 

args=$(getopt -n "$L_name" -o +2 -l bash-completion -- "$@")
eval set -- "$args"
while (($#)); do
	case "$1" in
	-2) g_use_gitlab2; ;;
	--bash-completion) break; ;;
	--) shift; break;
	esac
	shift
done

. ,lib_lib C_ "$@"

