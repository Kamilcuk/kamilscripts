#!/bin/bash
set -euo pipefail

run_curl() {
	local cmd
	cmd=(curl -sS -iL --header "Authorization: *****" "$@")
	L_info + "${cmd[@]}"
	if [[ -z "${GITLAB_TOKEN:-}" ]]; then
		L_fatal "GITLAB_TOKEN variable is empty!"
	fi
	cmd=(curl -sSLH "Authorization: Bearer ${GITLAB_TOKEN}" "$@")
	if "$DEBUG"; then
		L_log + "${cmd[@]@Q}"
	fi
	"${cmd[@]}"
}

hdr_get_data() { sed '/^\r$/,$!d'; }
hdr_get_header() { sed '1,/^\r$/!d'; }
hdr_get_link() {
	local tmp
	tmp=$(hdr_get_header | sed -n 's/^link:.* <\([^>]*\)>; rel="next".*/\1/p')
	printf "%s" "$tmp"
	[[ -n "$tmp" ]]
}

get_paginated() {
	local tmp acc
	acc=""
	while true; do
		tmp=$(run_curl -i "$@")
		acc+="$(hdr_get_data <<<"$tmp")"
		if ! link=$(<<<"$tmp" hdr_get_link) || [[ -z "$link" ]]; then break; fi
		set -- "$link"
	done
	<<<"$acc" jq -s add
}

###############################################################################`

# shellcheck disable=2145
C_GETRAW() {
	run_curl "${GITLAB_API_URL}/$@"
	echo
}

C_GET() {
	local path tmp
	path=$1
	shift
	get_paginated "${GITLAB_API_URL}/$path?pagination=keyset&per_page=100&order_by=id&sort=asc" "$@"
}

# shellcheck disable=2145
C_POST() {
	run_curl -X POST "${GITLAB_API_URL}/$@"
}

C_get_groups() {
	C_GET /groups
}

C_get_group_from_name() {
	C_get_groups | jq --arg name "$1" '.[] | select(.name == $name)'
}

C_list_projects_in_group() {
	if (($# != 1)); then L_fatal "Need one argument - group id"; fi
	C_GET "/groups/$1/projects"
}

C_list_projects_in_group_name() {
	if (($# != 1)); then L_fatal "Need one argument - group name"; fi
	C_list_projects_in_group "$(C_get_group_from_name "$1" | jq -r .id)"
}

C_project_get_link_to_CI_CD_Settings() {
	tmp=$(C_GET "/projects/$1" | jq -r .web_url)
	echo "$tmp/-/settings/ci_cd"
}

C_list_links_to_CI_CD_Settings_of_all_projects_in_group_name() {
	C_list_projects_in_group_name "$1" |
		jq '.[].id' |
		while IFS= read -r line; do
			C_project_get_link_to_CI_CD_Settings "$line"
		done
}

C_ci_lint() {
	if (($# != 1)); then
		if [[ -r   ./.gitlab-ci.yml ]]; then
			set -- ./.gitlab-ci.yml
		else
			L_fatal "Need one argument"
		fi
	fi
	if (($# == 0)); then L_usage; L_fatal "Needs file as argument"; fi

	tmp=$(
		jq --null-input --arg yaml "$(<"$1")" '.content=$yaml' |
		curl -Ss "https://gitlab.com/api/v4/ci/lint?include_merged_yaml=true" \
			--header 'Content-Type: application/json' \
			--data @-
	) &&
	jq <<<"$tmp" &&
	tmp=$(jq .status <<<"$tmp") &&
	[[ "$tmp" = "valid" ]]
}

C_list_current_user() {
	C_GET /user
}

C_get_current_user_id() {
	C_GET /user | jq .id
}

C_search_projects() {
	C_GETRAW "/search?scope=projects&search=$@"
}

C_search_project_id() {
	C_search_projects "$@" | jq -r '.[] | "\(.path_with_namespace)\t\(.id)"'
}

C_get_project_id() {
	C_search_project_id "$@" | {
		IFS=$'\t'
		read -r path id
		if ! read -r path2 id2; then
			printf "%s\n" "$id"
		else
			L_warn "Multiple projects found for this search query: $1"
			printf "%s\n" "$path" "$id"
			printf "%s\t%s\n" "$path2" "$id2"
			cat
			exit 1
		fi
	}
}

C_get_project_tags() {
	local id
	id=$(C_get_project_id "$@")
	C_GETRAW "/projects/$id/repository/tags"
}

C_repo_create() {
	if (($# < 1)); then L_fatal "Argument needed"; fi
	args=$(getopt -n "$L_name" -o d -l description:,public,private,internal,enable-issues::,enable-wiki:: -- "$@")
	eval set -- "$args"
	mode=
	issues=false
	wiki=false
	while (($#)); do
		case "$1" in
		-d|--description) description=$2; shift; ;;
		--private|--public|--internal) mode=${1//--/}; ;;
		--enable-issues) issues=${2:-true}; shift; ;;
		--enable-wiki) wiki=${2:-true}; shift; ;;
		--) shift; break; ;;
		*) L_fatal "Internal error"; ;;
		esac
		shift;
	done
	if [[ -z "$mode" ]]; then L_fatal "--public --private or --internal argument needed"; fi

	C_POST /projects "$@"
}

###############################################################################

: "${GITLAB_URL:="gitlab.com"}"
: "${GITLAB_TOKEN:=}"
: "${DEBUG:=false}"

. ,lib_lib -q 

args=$(getopt -n "$L_name" -o +2 -l bash-completion -- "$@")
eval set -- "$args"
while (($#)); do
	case "$1" in
	-2) GITLAB_URL=${GITLAB2_URL:-${GITLAB_URL}} GITLAB_TOKEN=${GITLAB2_TOKEN:-${GITLAB_TOKEN}}; ;;
	--bash-completion) break; ;;
	--) shift; break;
	esac
	shift
done

: "${GITLAB_API_URL:="https://${GITLAB_URL}/api/v4/"}"

. ,lib_lib C_ "$@"
