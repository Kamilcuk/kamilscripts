#!/bin/bash
set -euo pipefail

. ,lib_lib -l

sshload_default_callback() {
	L_run ssh "${@}"
}

ssh_expect_old() 
{ 
    expect -f <(cat <<'EOF'
# https://askubuntu.com/questions/93848/ssh-shell-launched-using-expect-doesnt-have-full-width-how-can-i-make-fix-it
# trap sigwinch and pass it to the child we spawned
trap {
	set rows [stty rows]
	set cols [stty columns]
	stty rows $rows columns $cols < $spawn_out(slave,name)
} WINCH

set cmd [lindex $argv 0]
set passfile [lindex $argv 1]
set args [lrange $argv 2 end]
spawn {*}$args
expect {
	-re "The authenticity of .* can't be established." {
		send "yes\r"
		exp_continue
	}
	-re ".*assword:" {
		set pass [read [open $passfile]]
		send -- $pass
		send -- "\r"
		exp_continue
	}
	-re "Last login:" {
		exp_continue
	}
	"$ " {}
	"# " {}
}

expect -re $
send -- "set +o history ; echo 04a74a83-e6f1-4f2f-a7a5-6971ab8e0b8e\r"
send -- "history -d \$((\$HISTCMD))\r"
expect "04a74a83-e6f1-4f2f-a7a5-6971ab8e0b8e\r"
send -- $cmd
send -- "echo a18357ab\"\"-d888-45e0-9f86-230a933659f1 ; set -o history \r"
expect "a18357ab-d888-45e0-9f86-230a933659f1\r"

interact
return
# interact
# expect eof
EOF
	) "$@"
}

sshload_callback_load_configuration_old() {
	if ((!SSH_INTERACTIVE)); then
		L_run sshpass -f "$g_passfile" ssh "$@"
		return "$?"
	fi
	if [[ -z "$g_sshload_sh" && -x ~/.config/sshload.sh ]]; then
		g_sshload_sh=~/.config/sshload.sh
	fi
	if [[ -n "$g_sshload_sh" ]]; then
		cmd=$(L_dryrun=0; L_run "$g_sshload_sh" "$SSH_INTERACTIVE" "$@")
	fi
	L_debug "$(declare -p g_sshload_sh cmd g_passfile)"
	if ((L_dryrun)); then
		L_run expect -f ... ssh -tt "$@"
		return
	fi
	set +e
	ssh_expect "$cmd"$'\n' "$g_passfile" stdbuf -o0 ssh -tt "$@" > >(
		if L_lmask_isblocked "L_LOG_DEBUG"; then
			output=1
			while IFS= read -r l; do
				case "$l" in
				(*"04a74a83-e6f1-4f2f-a7a5-6971ab8e0b8e"*) output=0; ;;
				(*"echo a18357ab-d888-45e0-9f86-230a933659f1"*) output=0; ;;
				(*"a18357ab-d888-45e0-9f86-230a933659f1"*) break; ;;
				esac
				if ((output)); then
					printf "%s\n" "$l"
				fi
			done
		fi
		exec stdbuf -o0 cat
	)
}

sshload_callback_load_configuration() {
	if ((!SSH_INTERACTIVE)); then
		L_run sshpass -f "$g_passfile" ssh "$@"
		return "$?"
	fi
	if [[ -z "$g_sshload_sh" && -x ~/.config/sshload.sh ]]; then
		g_sshload_sh=~/.config/sshload.sh
	fi
	cmd='if [[ -r ~/.bashrc ]]; then source ~/.bashrc; fi; '$'\n'
	if [[ -n "$g_sshload_sh" ]]; then
		cmd+=$( L_dryrun=0; L_run "$g_sshload_sh" "$SSH_INTERACTIVE" "$@" )
	fi
	L_debug "$(declare -p g_sshload_sh cmd g_passfile)"
	if ((L_dryrun)); then
		L_run expect -f ... ssh -tt "$@"
		return
	fi
	cmd=$(printf "%q" "$cmd")
	set +e
	trap '' ERR
	L_run sshpass -f "$g_passfile" ssh -tt "$@" "bash -c \"bash --rcfile <( printf %s $cmd ) -i\""
}

usage() {
	cat <<EOF
$ssh_usage

Usage: $L_NAME [all_ssh_options] [LONGOPTIONS] destination [command] 

Long options:
	--c --callback <callback>
	--i --interactiveconfig [config]
	--p --passfile <file>
	--v --verbose
	--q --quiet
	--n --dry-run
	--h --help

Written by Kamil Cukrowski 2021
EOF
}

# main ##############################################################################

ssh_usage=$( { ssh 2>&1 || :; } )
L_assert '[[ -n "$ssh_usage" ]]' "Internal error when getting ssh usage - it's empty"
ssh_opts1=$(
	<<<"$ssh_usage" \
	sed 's/\s*\[\([^][]*\)\] */\n\1\n/g' |
	sed '/^-/!d' |
	sed '/-.[^ ]/{ s/-//; }; s/-\(.\) .*/\1:/'
)
ssh_getopts=$(<<<"$ssh_opts1" paste -sd '')
ssh_opts_noarg=$(<<<"$ssh_opts1" sed '/:/d' | paste -sd '')
ssh_opts_arg=$(<<<"$ssh_opts1" sed '/:/!d; s/://g' | paste -sd '')
g_args=$(getopt -n "$L_NAME" -o "+$ssh_getopts" \
	-l c:,callback:,i::,interactiveconfig::,p:,passfile:,v,verbose,q,quiet,n,dry-run,h,help \
	-- "$@") || return 1
eval "set -- $g_args"
ssh_args=()
g_callback="sshload_default_callback"
g_sshload_sh=""
g_passfile=""
while (($#)); do
	case "$1" in
	(-[$ssh_opts_noarg]) ssh_args+=("$1"); ;;
	(-[$ssh_opts_arg]) ssh_args+=("$1" "$2"); shift; ;;
	(--C|--callback) g_callback="$2"; shift; ;;
	(--i|--interactiveconfig) g_callback=sshload_callback_load_configuration; g_sshload_sh="$2"; shift; ;;
	(--p|--passfile) g_passfile="$2"; shift; ;;
	(--v|--verbose) L_lmask_allow "L_LOG_DEBUG"; ;;
	(--q|--quiet) L_lmask_block "$L_LOG_INFO"; ;;
	(--n|--dry-run) L_dryrun=1; ;;
	(--h|--help) usage; exit 0; ;;
	(--) shift; break; ;;
	(*) L_fatal "Failed to parse argument: $1"; ;;
	esac
	shift
done
if (($# == 0)); then usage; L_fatal "Not enough arguments"; fi

SSH_INTERACTIVE=$(($# == 1)) "$g_callback" "${ssh_args[@]}" -- "$@"


