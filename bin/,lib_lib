#!/bin/bash

if [[ -z "${L_LIB_LIB_SOURCED:-}" ]]; then
L_LIB_LIB_SOURCE=true

L_name=${0##*/}

L_dir=${0%/*}

L_dryrun=false

L_loglevel=3

L_log() {
	printf "%s\n" "$L_name: $*" >&2
}

L_error() {
	L_log "ERROR:" "$@"
}

L_warn() {
	L_log "WARN:" "$@"
}

L_fatal() {
	L_error "$*"
	exit 2
}

L_function_exists() {
	[[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]
}

L_command_exists() {
	command -v "$@" >/dev/null 2>&1
}

L_hash() {
	hash "$@" >/dev/null 2>&1
}

L_logrun() {
	L_log "+" "$@"
	"$@"
}

L_run() {
	L_log "+" "${@@Q}"
	if ! "$L_dryrun"; then
		"$@"
	fi
}

L_list_functions_with_prefix() {
	compgen -A function | LC_ALL=C sed -n "s/^$*//p" | LC_ALL=C sort
}

L_am_I_sourced() {
	[[ "${BASH_SOURCE[0]}" != "${0}" ]]
}

L_trap_err() {
	L_error "fatal error on $(caller)"
}

trap L_trap_err ERR

fi

###############################################################################

# If this file is sourced with only a siungle argument -q then just let
# the upper definitions be visible. This is a library.
if L_am_I_sourced && (($# == 1)) && [[ "${1:-}" = '-q' ]]; then
	return
fi

###############################################################################

,lib_lib_usage() {
	cat <<'EOF'
Usage:
	# script.sh
	LIB_prefix_some_func() {
		desc="this func does that"
	}		
    prefix_some_func() {
		echo 'yay!'
	}
	source ,lib_lib 'prefix_' "$@"

	# then from command line:
	eval "$(script.sh --bash-autocompletion)"
	script.sh some_func


A library to be called from other libraries
This is a simple script to allow me to write:
- simple reusable programs
- with bash completion
and much more TODO!

Written by Kamil Cukrowski 2020
EOF
}

,lib_lib_error() {
	echo ",lib_lib: ERROR: $*" >&2
}

,lib_lib_fatal() {
	,lib_lib_error "$@"
	exit 3
}

,lib_lib_list_prefix_functions() {
	L_list_functions_with_prefix "$L_prefix"
}

,lib_lib_their_usage() {
	if L_function_exists usage; then
		local tmp saveifs
		tmp=$(,lib_lib_list_prefix_functions)
		saveifs="${IFS:-}"
		IFS=$'\n\r \t' read -r -d '' -a functions <<<"$tmp" ||:
		IFS="$saveifs"
		unset tmp
		usage "${functions[@]}"
		return 
	fi
	cat <<EOF
Usage: $L_name <COMMAND> [OPTIONS]

Commands:
$(
	{
		for f in $(,lib_lib_list_prefix_functions); do
			desc=""
			if L_function_exists LIB_"$L_prefix$f"; then
				LIB_"$L_prefix$f" "$f" "$L_prefix"
			fi
			echo "$f${desc:+#}$desc"
		done
		echo "--bash-completion#Generate bash completion to be eval'ed."
	} |
	if hash column 2>/dev/null >&2; then
		column -t -s '#' -o ' - '
	else
		sed 's/#/ - /'
	fi | sed 's/^/  /'
)

EOF
}

,lib_lib_show_best_match() {
	if L_hash fzf &&
			tmp=$(,lib_lib_list_prefix_functions | fzf -0 -1 -f "$1") &&
			[[ -n "$tmp" ]]; then
		echo "   Maybe you meant: $tmp ?" >&2
	fi
}

###############################################################################

if ! L_am_I_sourced; then
	,lib_lib_usage
	,lib_lib_fatal "Not sourced"
fi
if (($# == 0)); then ,lib_lib_fatal "called with less then one argument"; fi
L_prefix=$1
shift
if [[ -z "$L_prefix" ]]; then ,lib_lib_fatal "first argument is empty"; fi

if [[ "${1:-}" = '--bash-completion' ]]; then
	printf "%q\n" complete -W "$(,lib_lib_list_prefix_functions | paste -sd' ')" "$0" "$(basename -- "$0")" | paste -sd' '
	exit
fi
if (($# == 0)); then
	,lib_lib_their_usage "$@"
	exit
fi

L_mode=$1
shift
if ! L_function_exists "$L_prefix$L_mode"; then
	,lib_lib_their_usage
	,lib_lib_error "Unknown command: $L_mode"
	,lib_lib_show_best_match "$L_mode"
	exit
fi
"$L_prefix$L_mode" "$@"



