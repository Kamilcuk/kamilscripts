#!/bin/bash
# This is a collection of libraries that I seem to use over and over
# again and again inm every script I write.
# It's here to simplify my use of it.
# Written by Kamil Cukrowski
# Licensed jointly under MIT License and Beerware License
# SPDX-License-Identifier: MIT + Beerware

# shellcheck disable=SC2034

# Library start {{{

shopt -s extglob

# Source only once, to speed up
if [[ -z "${L_LIB_LIB_SOURCED:-}" ]]; then
L_LIB_LIB_SOURCED=true
readonly L_LIB_LIB_SOURCED

# }}}
# Globals {{{

L_name=${0##*/}
L_dir=${0%/*}
L_NAME="$L_name"
L_DIR="$L_dir"
readonly L_NAME L_DIR

# }}}
# Colors {{{

L_BOLD=$'\E[1m'
L_BRIGHT=$'\E[1m'
L_DIM=$'\E[2m'
L_FAINT=$'\E[2m'
L_STANDOUT=$'\E[3m'
L_UNDERLINE=$'\E[4m'
L_BLINK=$'\E[5m'
L_REVERSE=$'\E[7m'
L_CONCEAL=$'\E[8m'
L_HIDDEN=$'\E[8m'
L_CROSSEDOUT=$'\E[9m'

L_FONT0=$'\E[10m'
L_FONT1=$'\E[11m'
L_FONT2=$'\E[12m'
L_FONT3=$'\E[13m'
L_FONT4=$'\E[14m'
L_FONT5=$'\E[15m'
L_FONT6=$'\E[16m'
L_FONT7=$'\E[17m'
L_FONT8=$'\E[18m'
L_FONT9=$'\E[19m'

L_FRAKTUR=$'\E[20m'
L_DOUBLE_UNDERLINE=$'\E[21m'
L_NODIM=$'\E[22m'
L_NOSTANDOUT=$'\E[23m'
L_NOUNDERLINE=$'\E[24m'
L_NOBLINK=$'\E[25m'
L_NOREVERSE=$'\E[27m'
L_NOHIDDEN=$'\E[28m'
L_REVEAL=$'\E[28m'
L_NOCROSSEDOUT=$'\E[29m'

L_BLACK=$'\E[30m'
L_RED=$'\E[31m'
L_GREEN=$'\E[32m'
L_YELLOW=$'\E[33m'
L_BLUE=$'\E[34m'
L_MAGENTA=$'\E[35m'
L_CYAN=$'\E[36m'
L_LIGHT_GRAY=$'\E[37m'
L_DEFAULT=$'\E[39m'
L_FOREGROUND_DEFAULT=$'\E[39m'

L_BACKGROUND_BLUE=$'\E[44m'
L_BACKGROUND_CYAN=$'\E[46m'
L_BACKGROUND_DEFAULT=$'\E[49m'
L_BACKGROUND_GREEN=$'\E[42m'
L_BACKGROUND_LIGHT_GRAY=$'\E[47m'
L_BACKGROUND_MAGENTA=$'\E[45m'
L_BACKGROUND_YELLOW=$'\E[43m'
L_B_BLACK=$'\E[40m'
L_B_BLUE=$'\E[44m'
L_B_CYAN=$'\E[46m'
L_B_GREEN=$'\E[42m'
L_B_LIGHT_GRAY=$'\E[47m'
L_B_MAGENTA=$'\E[45m'
L_B_RED=$'\E[41m'
L_B_YELLOW=$'\E[43m'

L_FRAMED=$'\E[51m'
L_ENCIRCLED=$'\E[52m'
L_OVERLINED=$'\E[53m'
L_NOENCIRCLED=$'\E[54m'
L_NOFRAMED=$'\E[54m'
L_NOOVERLINED=$'\E[55m'

L_DARK_GRAY=$'\E[90m'
L_LIGHT_RED=$'\E[91m'
L_LIGHT_GREEN=$'\E[92m'
L_LIGHT_YELLOW=$'\E[93m'
L_LIGHT_BLUE=$'\E[94m'
L_LIGHT_MAGENTA=$'\E[95m'
L_LIGHT_CYAN=$'\E[96m'
L_WHITE=$'\E[97m'

L_BACKGROUND_DARK_GRAY=$'\E[100m'
L_BACKGROUND_LIGHT_BLUE=$'\E[104m'
L_BACKGROUND_LIGHT_CYAN=$'\E[106m'
L_BACKGROUND_LIGHT_GREEN=$'\E[102m'
L_BACKGROUND_LIGHT_MAGENTA=$'\E[105m'
L_BACKGROUND_LIGHT_RED=$'\E[101m'
L_BACKGROUND_LIGHT_YELLOW=$'\E[103m'
L_BACKGROUND_WHITE=$'\E[107m'

L_B_DARK_GRAY=$'\E[100m'
L_B_LIGHT_BLUE=$'\E[104m'
L_B_LIGHT_CYAN=$'\E[106m'
L_B_LIGHT_GREEN=$'\E[102m'
L_B_LIGHT_MAGENTA=$'\E[105m'
L_B_LIGHT_RED=$'\E[101m'
L_B_LIGHT_YELLOW=$'\E[103m'
L_B_WHITE=$'\E[107m'

# It resets color and font.
L_COLORRESET=$'\E(B\E[m'

L_ansi_up() { printf '\E[%dA' "$@"; }
L_ansi_down() { printf '\E[%dB' "$@"; }
L_ansi_right() { printf '\E[%dC' "$@"; }
L_ansi_left() { printf '\E[%dD' "$@"; }
L_ansi_next_line() { printf '\E[%dE' "$@"; }
L_ansi_prev_line() { printf '\E[%dF' "$@"; }
L_ansi_set_column() { printf '\E[%dG' "$@"; }
L_ansi_set_position() { printf '\E[%d;%dH' "$@"; }
L_ansi_clear_screen_until_end() { printf '\E[0J'; }
L_ansi_clear_screen_until_beginning() { printf '\E[1J'; }
L_ansi_clear_screen() { printf '\E[2J'; }
L_ansi_clear_line_until_end() { printf '\E[0K'; }
L_ansi_clear_line_until_beginning() { printf '\E[1K'; }
L_ansi_clear_line() { printf '\E[2K'; }
L_ansi_save_position() { printf '\E7'; }
L_ansi_restore_position() { printf '\E8'; }

# L_usecolor variable
# For example use: echo "${L_usecolor:+$L_RED}someoutput${L_usecolor:+$L_COLORRESET}"
L_usecolor=
if [ -t 1 ]; then
	L_usecolor=yes
fi

# }}}
# Loglevel library {{{

L_LOG_EMERG=0
L_LOG_ALERT=1
L_LOG_CRIT=2
L_LOG_ERR=3
L_LOG_WARNING=4
L_LOG_NOTICE=5
L_LOG_INFO=6
L_LOG_DEBUG=7
L_LOG_PRIMASK=7
L_LOG_PRIORITY_NAMES=(
	[L_LOG_EMERG]="emerg"
	[L_LOG_ALERT]="alert"
	[L_LOG_CRIT]="crit"
	[L_LOG_ERR]="err"
	[L_LOG_WARNING]="warning"
	[L_LOG_NOTICE]="notice"
	[L_LOG_INFO]="info"
	[L_LOG_DEBUG]="debug"
)
L_LOG_COLORS=(
	[L_LOG_EMERG]="${L_BOLD}${L_RED}"
	[L_LOG_ALERT]="${L_BOLD}${L_RED}"
	[L_LOG_CRIT]="${L_BOLD}${L_RED}"
	[L_LOG_ERR]="${L_BOLD}${L_RED}"
	[L_LOG_WARNING]="${L_BOLD}${L_YELLOW}"
	[L_LOG_NOTICE]="${L_BOLD}${L_CYAN}"
	[L_LOG_INFO]=""
	[L_LOG_DEBUG]=""
)

# facility codes
L_LOG_KERN=0         # kernel messages
L_LOG_USER=8         # random user-level messages
L_LOG_MAIL=16        # mail system
L_LOG_DAEMON=24      # system daemons
L_LOG_AUTH=32        # security/authorization messages
L_LOG_SYSLOG=40      # messages generated internally by syslogd
L_LOG_LPR=48         # line printer subsystem
L_LOG_NEWS=56        # network news subsystem
L_LOG_UUCP=64        # UUCP subsystem
L_LOG_CRON=72        # clock daemon
L_LOG_AUTHPRIV=80    # security/authorization messages (private)
L_LOG_FTP=88         # ftp daemon

# other codes through 15 reserved for system use
L_LOG_LOCAL0=128    # reserved for local use
L_LOG_LOCAL1=136    # reserved for local use
L_LOG_LOCAL2=144    # reserved for local use
L_LOG_LOCAL3=152    # reserved for local use
L_LOG_LOCAL4=160    # reserved for local use
L_LOG_LOCAL5=168    # reserved for local use
L_LOG_LOCAL6=176    # reserved for local use
L_LOG_LOCAL7=184    # reserved for local use

# Additional log levels - max is 63
L_LOG_EMERG1=8
L_LOG_ALERT1=9
L_LOG_CRIT1=10
L_LOG_ERR1=11
L_LOG_WARNING1=12
L_LOG_NOTICE1=13
L_LOG_INFO1=14
L_LOG_DEBUG1=15
#
L_LOG_EMERG2=16
L_LOG_ALERT2=17
L_LOG_CRIT2=18
L_LOG_ERR2=19
L_LOG_WARNING2=20
L_LOG_NOTICE2=21
L_LOG_INFO2=22
L_LOG_DEBUG2=23
#
L_LOG_EMERG3=32
L_LOG_ALERT3=33
L_LOG_CRIT3=34
L_LOG_ERR3=35
L_LOG_WARNING3=36
L_LOG_NOTICE3=37
L_LOG_INFO3=38
L_LOG_DEBUG3=39
#
L_LOG_EMERG5=40
L_LOG_ALERT5=41
L_LOG_CRIT5=42
L_LOG_ERR5=43
L_LOG_WARNING5=44
L_LOG_NOTICE5=45
L_LOG_INFO5=46
L_LOG_DEBUG5=47
#
L_LOG_EMERG4=48
L_LOG_ALERT4=49
L_LOG_CRIT4=50
L_LOG_ERR4=51
L_LOG_WARNING4=52
L_LOG_NOTICE4=53
L_LOG_INFO4=54
L_LOG_DEBUG4=55
#
L_LOG_EMERG5=56
L_LOG_ALERT5=57
L_LOG_CRIT5=58
L_LOG_ERR5=59
L_LOG_WARNING5=60
L_LOG_NOTICE5=61
L_LOG_INFO5=62
L_LOG_DEBUG5=63

# Logging mask - what is allowed, what is not.
L_logmask=127
L_logmask_is_allowed() {   ((  ( L_logmask & (1 << ($1) ) ) )); }
L_logmask_is_blocked() {   (( !( L_logmask & (1 << ($1) ) ) )); }
L_logmask_allow() {        (( L_logmask |= (  (1 << ($1) ) ) , 1)); }
L_logmask_block() {        (( L_logmask &= ( ~(1 << ($1) ) ) , 1)); }
L_logmask_allow_all() { L_logmask=-1; }
L_log_set_level() {        (( L_logmask =  (1 << ( ($1) + 1)) - 1  , 1)); }

L_logname=
L_log_open_stdout() {
	L_logl_backend() {
		printf "%s\n" "${L_logname:-$L_name}: ${*:2}" >&2
	}
}
L_log_open_logger() {
	eval '
	L_logl_backend() {
		logger '"${1:--s}"' -e -t "${L_logname:-$L_name}" -p "$(('"${2:-L_LOG_LOCAL7}"' | ($1) & L_LOG_PRIMASK))" "${*:2}"
	}
	'
}
L_log_open_stdout
# shellcheck disable=SC2140
L_logl() {
	if L_logmask_is_allowed "$1"; then
		set -- "$(($1 & L_LOG_PRIMASK))" "${*:2}"
		L_logl_backend "$1" \
"${L_usecolor:+${L_LOG_COLORS[$1]}}"\
"${L_LOG_PRIORITY_NAMES[$1]:+${L_LOG_PRIORITY_NAMES[$1]}: }"\
"$2"\
"${L_usecolor:+${L_COLORRESET}}"
	fi
}

L_log() {
	if L_logmask_is_allowed "L_LOG_INFO"; then
		L_logl_backend "$L_LOG_INFO" "$@"
	fi
}

L_emerg() { L_logl "L_LOG_EMERG" "$@"; }
L_alert() { L_logl "L_LOG_ALERT" "$@"; }
L_crit() { L_logl "L_LOG_CRIT" "$@"; }
L_err() { L_logl "L_LOG_ERR" "$@"; }
L_warning() { L_logl "L_LOG_WARNING" "$@"; }
L_notice() { L_logl "L_LOG_NOTICE" "$@"; }
L_info() { L_logl "L_LOG_INFO" "$@"; }
L_debug() { L_logl "L_LOG_DEBUG" "$@"; }
L_panic() { L_logl "L_LOG_PANIC" "$@"; }
L_error() { L_logl "L_LOG_ERR" "$@"; }
L_warn() { L_logl "L_LOG_WARNING" "$@"; }

# shellcheck disable=SC2016
_L_loglibrary_test() {
	(
		set -euo pipefail
		u=17070a0d-8ebf-465b-b630-281e89fd6df2
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_INFO
		L_unittest_assert '! L_debug "$u" 2>&1 | grep -q "$u"'
		L_unittest_assert 'L_info g "$u" 2>&1 | grep -q "$u"'
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_INFO

		L_unittest_cmd '' L_logmask_block L_LOG_INFO
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_INFO
		L_unittest_cmd '' ! L_logmask_is_allowed L_LOG_INFO

		L_unittest_cmd '' L_logmask_allow L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_DEBUG
		L_unittest_cmd '' ! L_logmask_is_blocked L_LOG_DEBUG

		L_unittest_cmd '' L_logmask_block L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG

		L_unittest_cmd '' L_log_set_level L_LOG_NOTICE
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_INFO
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_NOTICE
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_WARNING
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG2

		L_unittest_cmd '' L_log_set_level L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_INFO
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_NOTICE
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_WARNING

		L_unittest_cmd '' L_log_set_level L_LOG_CRIT
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_CRIT
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_INFO
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_NOTICE
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_WARNING

		L_unittest_cmd '' L_log_set_level L_LOG_INFO
		L_unittest_cmd '' L_logmask_allow L_LOG_DEBUG2
		L_unittest_cmd '' L_logmask_allow L_LOG_DEBUG3
		L_unittest_cmd '' L_logmask_is_blocked L_LOG_DEBUG1
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_DEBUG3
		L_unittest_cmd '' L_logmask_is_allowed L_LOG_DEBUG2

		L_unittest_cmd '' L_logmask_allow L_LOG_EMERG5
	)
}

# }}}
# Additional functions {{{

# Output a string with the same quotating style as does bash in set -x
L_set_x_quote() { local tmp; tmp=$({ set -x; : "$@"; } 2>&1); printf "%s\n" "${tmp:5}"; }

# Output a critical message and exit the script.
L_fatal() { L_crit "$*"; exit 2; }

# Eval the first argument - if it returns failure, then fatal.
L_assert() { if eval '!' "$1"; then L_print_traceback2; L_fatal "assertion $1 failed: ${*:2}"; fi }

# Return success if function exists.
L_function_exists() { [[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]; }
L_fn_exists()       { [[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]; }

L_command_exists() { command -v "$@" >/dev/null 2>&1; }
L_cmd_exists() { command -v "$@" >/dev/null 2>&1; }

L_hash() { hash "$@" >/dev/null 2>&1; }
L_am_I_sourced() { [[ "${BASH_SOURCE[0]}" != "${0}" ]]; }

# shellcheck disable=SC2236
L_isset()     { [[ ! -z "${var+x}" ]]; }

# shellcheck disable=SC2236
L_var_isset() { [[ ! -z "${var+x}" ]]; }

L_var_is_array() { 
	[[ "$(declare -p "$1" 2> /dev/null)" == "declare -a"* ]]
}

L_logrun() {
	L_log "+ $*"
	"$@"
}

L_is_false() {
	case "$1" in
	(0+(0)) return 0; ;;
	([fF]) return 0; ;;
	([fF][aA][lL][sS][eE]) return 0; ;;
	esac
	return 1
}

L_is_true() {
	case "$1" in
	(0*(0)) return 1; ;;
	([0-9]*([0-9])) return 0; ;;
	([tT]) return 0; ;;
	([tT][rR][uU][eE]) return 0; ;;
	esac
	return 1
}

: "${L_dryrun:=0}"
L_run_log() {
	local _L_tmp
	_L_tmp="$1" # loglevel
	shift
	if L_is_true "${L_dryrun:-}"; then
		L_logl "$_L_tmp" "DRYRUN: + $*"
	else
		L_logl "$_L_tmp" "+ $*"
		"$@"
	fi
}
L_run() {
	L_run_log L_LOG_INFO "$@"
}

L_list_functions_with_prefix() {
	compgen -A function | LC_ALL=C sed -n "s/^$*//p" | LC_ALL=C sort
}

L_time_all() {
	command time -f \
"	Elapsed real time (in [hours:]minutes:seconds):	%E
	Elapsed real time (in seconds):	%e
	Total number of CPU-seconds that the process spent in kernel mode:	%S
	Total number of CPU-seconds that the process spent in user mode:	%U
	Percentage of the CPU that this job got, computed as (%U + %S) / %E:	%P
	Maximum resident set size of the process during its lifetime, in Kbytes:	%M
	Average resident set size of the process, in Kbytes:	%t
	Average total (data+stack+text) memory use of the process, in Kbytes:	%K
	Average size of the process's unshared data area, in Kbytes:	%D
	Average size of the process's unshared stack space, in Kbytes:	%p
	Average size of the process's shared text space, in Kbytes:	%X
	System's page size, in bytes.  This is a per-system constant, but varies between systems:	%Z
	Number of major page faults that occurred while the process was running:	%F
	Number of minor, or recoverable, page faults:	%R
	Number of times the process was swapped out of main memory:	%W
	Number of times the process was context-switched involuntarily (because the time slice expired):	%c
	Number of waits: times that the program was context-switched voluntarily, for instance while waiting for an I/O operation to complete:	%w
	Number of filesystem inputs by the process:	%I
	Number of filesystem outputs by the process:	%O
	Number of socket messages received by the process:	%r
	Number of socket messages sent by the process:	%s
	Number of signals delivered to the process:	%k
	Name and command-line arguments of the command being timed:	%C
	Exit status of the command:	%x" "$@"
	# "
}

###############################################################################

# https://unix.stackexchange.com/questions/39623/trap-err-and-echoing-the-error-line
## Outputs Front-Mater formatted failures for functions not returning 0
## Use the following line after sourcing this file to set failure trap
##    trap 'failure "LINENO" "BASH_LINENO" "${BASH_COMMAND}" "${?}"' ERR
L_trap_err_failure() {
    local -n _lineno="LINENO"
    local -n _bash_lineno="BASH_LINENO"
    local _last_command="${2:-$BASH_COMMAND}"
    local _code="${1:-0}"

    ## Workaround for read EOF combo tripping traps
    if ! ((_code)); then
        return "${_code}"
    fi

    local _last_command_height
	_last_command_height="$(wc -l <<<"${_last_command}")"

    local -a _output_array=()
    _output_array+=(
        '---'
        "lines_history: [${_lineno} ${_bash_lineno[*]}]"
        "function_trace: [${FUNCNAME[*]}]"
        "exit_code: ${_code}"
    )

    if [[ "${#BASH_SOURCE[@]}" -gt '1' ]]; then
        _output_array+=('source_trace:')
        for _item in "${BASH_SOURCE[@]}"; do
            _output_array+=("  - ${_item}")
        done
    else
        _output_array+=("source_trace: [${BASH_SOURCE[*]}]")
    fi

    if [[ "${_last_command_height}" -gt '1' ]]; then
        _output_array+=(
            'last_command: ->'
            "${_last_command}"
        )
    else
        _output_array+=("last_command: ${_last_command}")
    fi

    _output_array+=('---')
    printf '%s\n' "${_output_array[@]}" >&2
    exit "$_code"
}

L_print_traceback2() {
	echo "Traceback from pid $BASHPID (most recent call last):"
	local i s l f tmp offset
	offset=${1:-0}
	for ((i = ${#BASH_SOURCE[@]} - 1; i > offset; --i)); do
		s=${BASH_SOURCE[i]}
		l=${BASH_LINENO[i - 1]}
		f=${FUNCNAME[i]}
		echo "  File $(printf "%q" "$s"), line $l, in $f"
		if tmp=$(awk -v "L=$l" -v M=2 'NR>L-M && NR<L+M { printf "%-5d%3s%s\n",NR,(NR==L?">> ":""),$0 }' "$s" 2>/dev/null) &&
				[[ -n "$tmp" ]]; then
			echo "$tmp"
		fi
	done
	L_crit "Command returned with non-zero exit status: ${1:-0}"
}

L_trap_err_show_source() {
	local idx=${1:-0}
    echo "Traceback:"
    awk -v L="${BASH_LINENO[idx]}" -v M=3 'NR>L-M && NR<L+M { printf "%-5d%3s%s\n",NR,(NR==L?">> ":""),$0 }' "${BASH_SOURCE[idx+1]}"
	L_crit "command returned with non-zero exit status"
}

L_trap_err_small() {
	L_error "fatal error on $(caller)"
}

L_trap_err_enable() {
	L_trap_err() {
		local _code="${1:-0}"
		## Workaround for read EOF combo tripping traps
		if ! ((_code)); then
			return "${_code}"
		fi
		{
			#L_trap_err_show_source 1 "$@"
			L_print_traceback2 1 "$@"
		} >&2 ||:
		exit "$_code"
	}
}

L_trap_err_disable() {
	L_trap_err() { :; }
}

if ! L_fn_exists L_trap_err; then
	L_trap_err_enable
fi


if [[ "$-" =~ e ]]; then
	set -E -o functrace
	trap 'L_trap_err "$?" "$BASH_COMMAND" -- "${BASH_SOURCE[@]}" -- "${BASH_LINENO[@]}" -- "${FUNCNAME[@]}"' ERR
fi

###############################################################################

L_kill_all_jobs() {
	local IFS=$'\n' j
	for j in $(jobs | awk '{gsub("[^0-9]","",$1);print $1}'); do kill "%$j"; done
}

_L_lib_drop_L_prefix() {
	for i in run fatal logl log emerg alert crit err warning notice info debug panic error warn; do
		eval "$i() { L_$i \"\$@\"; }"
	done
}

L_sed_show_diff() {
	(
		file="${*: -1}"
		tmpf=$(mktemp)
		trap 'rm -f "$tmpf"' EXIT
		sed "$@" > "$tmpf"
		diff "$file" "$tmpf" ||:
		if [[ "${L_LIB_LIB_SED_INPLACE:-}" = 'true' ]]; then
			mv "$tmpf" "$file"
		fi
	)
}

L_sed_inplace_show_diff() {
	(
		L_LIB_LIB_SED_INPLACE=true
		L_sed_show_diff "$@"
	)
}

L_is_valid_variable_name() {
	[[ "$1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]
}

L_str_is_print() {
	grep -Fq '[[:print:]]' <<<"$*"
}

# }}}
# L_unittest {{{

_L_unittest_internal() {
	local _L_tmp=0 _L_invert=0
	if [[ "$3" == "!" ]]; then
		_L_invert=1
		shift
	fi
	"${@:3}" || _L_tmp=$?
	(( _L_invert ? (_L_tmp = !_L_tmp) : 1 , 1 ))
	: "${_L_unittest_result:=0}"
	if ((_L_tmp)); then
		echo -n "${L_usecolor:+${L_RED}${L_BRIGHT}}"
	fi
	echo -n "${FUNCNAME[2]}:${BASH_LINENO[1]}${1:+: }${1:-}: "
	if ((_L_tmp == 0)); then
		echo "${L_usecolor:+${L_GREEN}}OK${L_usecolor:+${L_COLORRESET}}"
	else
		(( _L_unittest_result |= 1 ))
		_L_tmp=("${@:3}")
		echo "expression ${_L_tmp[*]} FAILED!${2:+ }${2:-}${L_usecolor:+${L_COLORRESET}}"
		return 1
	fi
} >&2

L_unittest_assert() {
	_L_unittest_internal "test eval ${1}" "${*:2}" eval "$1" ||:
}

L_unittest_checkexit() {
	local _L_ret
	_L_ret=0
	"${@:2}" || _L_ret=$?
	_L_unittest_internal "test exit of ${*:2} is $1" "$_L_ret != $1" [ "$_L_ret" -eq "$1" ] ||:
}

L_unittest_evalcheckexit() {
	local _L_ret
	_L_ret=0
	eval "${@:2}" || _L_ret=$?
	_L_unittest_internal "test exit of ${*:2} is $1" "$_L_ret != $1" [ "$_L_ret" -eq "$1" ] ||:
}

L_unittest_cmd() {
	_L_unittest_internal "test ${*:2}" "" "${@:2}" ||:
}

L_unittest_pipes() {
	local op='='
	if [[ "$1" = "!" ]]; then
		op='!='
		shift
	fi
	local a b
	a=$(< "$1")
	b=$(< "$2")
	if ! _L_unittest_internal "test pipes${3:+ $3}" "$4" [ "$a" "$op" "$b" ]; then
		_L_unittest_showdiff "$a" "$b"
		return 1
	fi
}

_L_unittest_showdiff() {
	if [[ "$1" =~ ^[[:print:]]*$ && "$2" =~ ^[[:print:]]*$ ]]; then
		sdiff <(cat <<<"$1") - <<<"$2"
	else
		sdiff <(xxd -p <<<"$1") <(xxd -p <<<"$2")
	fi
}

L_unittest_vareq() {
	if ! _L_unittest_internal "test: \$$1=${!1} == $2" "" [ "${!1}" == "$2" ]; then
		_L_unittest_showdiff "${!1}" "$2"
		return 1
	fi
}

L_unittest_eq() {
	if ! _L_unittest_internal "test: $1 == $2" "" [ "$1" == "$2" ]; then
		_L_unittest_showdiff "${!1}" "$2"
		return 1
	fi
}

# }}}
# trapchain library{{{

# printf "%q" "$(seq 255 | xargs printf "%02x\n" | xxd -r -p)"
_L_allchars=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377'

L_get_trap_number_from_name() {
	trap -l | 
		sed 's/[ \t]*\([0-9]\+\))[ \t]*\([^ \t]\+\)[ \t]*/\1 \2\n/g; s/\n$//' |
		while IFS=' ' read -r a b; do
			if [[ "$b" == $1 ]]; then
				echo "$a"
			fi
		done
}

L_get_trap_name() {
	(
		trap ': 0738dc3c-6716-44a1-960a-991b0ec4abaa' "$1"
		trap -p
	) | while IFS= read -r line; do
		if
			[[ "$line" == *'0738dc3c-6716-44a1-960a-991b0ec4abaa'* ]] &&
			[[ "$line" =~ [^\ ]*$ ]]
		then
				printf %s "${BASH_REMATCH[0]}"
		fi
	done
}

L_extract_trap() {
	local tmp
	tmp=$(L_get_trap_name "$@")
	trap -p "$tmp" |
		sed '1s/^trap -- //; $s/ [^ ]\+$//' |
		sed "1s/^'//; s/'\\\\''/'/g; \$s/'$//"
}

_L_trapchain_callback() {
	# This is what it takes.
	local _L_tmp
	_L_tmp=_L_trapchain_data_$1
	eval "${!_L_tmp}"
}

# shellcheck disable=2064
L_trapchain() {
	local name
	name=$(L_get_trap_name "$2") &&
	trap "_L_trapchain_callback $name" "$name" &&
	eval "_L_trapchain_data_$2=\"\$1\"\$'\\n'\"\${_L_trapchain_data_$2:-}\""
}


# shellcheck disable=2064
# shellcheck disable=2016
_L_trapchain_test() {
	local tmp
	local allchars
	tmp=$(
		L_trapchain 'echo -n "!"' EXIT
		L_trapchain 'echo -n world' EXIT
		L_trapchain 'echo -n " "' EXIT
		L_trapchain 'echo -n hello' EXIT
	)
	L_unittest_assert '[[ "$tmp" == "hello world!" ]]' "tmp=$tmp"
	allchars="$_L_allchars"
	tmp=$(
		printf -v tmp %q "$allchars"
		L_trapchain 'echo -n "hello"' SIGUSR1
		L_trapchain "echo $tmp" SIGUSR1
		L_trapchain 'echo -n world' SIGUSR2
		L_trapchain 'echo -n " "' SIGUSR2
		L_trapchain 'echo -n "!"' EXIT
		L_raise SIGUSR1
		L_raise SIGUSR2
	)
	local res
	res="$allchars"$'\n'"hello world!"
	L_unittest_assert '[[ "$tmp" == "$res" ]]' $'\n'"tmp=${tmp}"$'\n'"res=${res}"
	(
		trap "$_L_allchars" "$(L_get_trap_number_from_name SIGUSR1)"
		tmp=$(L_extract_trap SIGUSR1)
		L_unittest_vareq tmp "$_L_allchars"
	)
}

L_raise() {
	kill -s "$1" "$BASHPID"
}

# }}}
# Map {{{
# L_map consist of an empty initial newline.
# Then follows map name, follows a spce, and then printf %q of the value.
#
#                     # empty initial newline
#     key $'value'
#     key2 $'value2'
#
# This format matches the regexes used in L_map_get for easy extraction using bash
# Variable substituation.

L_map_init() {
	printf -v "$1" "%s" ""
}

L_map_clear() {
	if ! _L_map_check "$1" "$2"; then return 2; fi
	local _L_map_name
	_L_map_name=${!1}
	_L_map_name="${_L_map_name/$'\n'"$2 "+([!$'\n'])/}"
	printf -v "$1" %s "$_L_map_name"
}

L_map_setdefault() {
	if ! L_map_has "$@"; then
		L_map_set "$@"
	fi
}

L_map_set() {
	L_map_clear "$1" "$2"
	local _L_map_name _L_map_name2
	_L_map_name=${!1}
	# This code depends on that `printf %q` _never_ prints a newline, instead it does $'\n'.
	# I add key-value pairs in chunks with preeceeding newline.
	printf -v _L_map_name2 %q "${*:3}"
	_L_map_name+=$'\n'"$2 $_L_map_name2"
	printf -v "$1" %s "$_L_map_name"
}

L_map_append() {
	local _L_map_name
	if L_map_getv _L_map_name "$1" "$2";then
		L_map_set "$1" "$2" "$_L_map_name${4:-}$3"
	else
		L_map_set "$1" "$2" "$3"
	fi
}

# Usage: L_map_getv var map attribute [default]
# Assigns the value of _attribute_ in _map_. If the attribute
# is not set within the map, then assigns _default_ if given and
# returns with 1.
# You want to prefer this version of L_map_get
L_map_getv() {
	if ! _L_map_check "$1" "$2" "$3"; then return 2; fi
	local _L_map_name
	_L_map_name=${!2}
	local _L_map_name2
	_L_map_name2="$_L_map_name"
	# Remove anything in front of the newline followed by key followed by space.
	# Because the key can't have newline not space, it's fine.
	_L_map_name2=${_L_map_name2##*$'\n'"$3 "}
	# If nothing was removed, then the key does not exists.
	if [[ "$_L_map_name2" == "$_L_map_name" ]]; then
		if (($# >= 4)); then
			printf -v "$1" %s "${*:4}"
		fi
		return 1
	fi
	# Remove from the newline until the end and print with eval.
	# The key was inserted with printf %q, so it has to go through eval now.
	_L_map_name2=${_L_map_name2%%$'\n'*}
	eval "printf -v \"\$1\" %s $_L_map_name2"
}

L_map_get() {
	local tmp="" ret=0
	L_map_getv tmp "$@" || ret=$?
	printf "%s\n" "$tmp"
	return "$ret"
}

L_map_has() {
	if ! _L_map_check "$1" "$2"; then return 2; fi
	local _L_map_name
	_L_map_name=${!1}
	[[ "$_L_map_name" == *$'\n'"$2 "* ]]
}

# List all keys in the map.
L_map_keys() {
	local _L_map_name
	_L_map_name=${!1}
	local oldIFS key val
	oldIFS=$IFS
	IFS=' '
	while read -r key val; do
		if [[ -z "$key" ]]; then continue; fi
		printf "%s\n" "$key"
	done <<<"$_L_map_name"
}

# List items with tab separated key and value.
# Note: value is the output from printf %q - it needs to be eval-ed.
L_map_items() {
	local _L_map_name
	_L_map_name=${!1}
	local key val
	while read -r key val; do
		if [[ -z "$key" ]]; then continue; fi
		printf "%s\t%s\n" "$key" "$val"
	done <<<"$_L_map_name"
}

# Load all keys to variables with the name of $prefix$key.
# @param $1 map variable
# @param $2 prefix
# @param [$3...] Optional list of keys to load. If not set, all are loaded.
L_map_load() {
	if ! _L_map_check "$@"; then return 2; fi
	local _L_map_name
	_L_map_name=${!1}
	local _L_oldIFS _L_key _L_val
	_L_oldIFS="$IFS"
	IFS=' '
	while read -r _L_key _L_val; do
		if [[ -z "$_L_key" ]]; then continue; fi
		if (($# > 2)); then
			for _L_tmp in "${@:3}"; do
				if [[ "$_L_tmp" == "$_L_key" ]]; then
					eval "printf -v \"\$2\$_L_key\" %s $_L_val"
					break
				fi
			done
		else
			eval "printf -v \"\$2\$_L_key\" %s $_L_val"
		fi
	done <<<"$_L_map_name"
	IFS="$_L_oldIFS"
}

_L_map_check() {
	local i
	for i in "$@"; do
		if ! L_is_valid_variable_name "$i"; then
			L_error "L_map: ${FUNCNAME[1]}: is not valid variable name: $i";
			return 1
		fi
	done
}

# shellcheck disable=2018
_L_map_test() {
	local var tmp
	var=123
	tmp=123
	L_map_init var
	L_map_set var a 1
	L_unittest_pipes <(L_map_get var a) <(echo -n 1)
	L_unittest_pipes <(L_map_get var b) <(:)
	L_map_set var b 2
	L_unittest_pipes <(L_map_get var a) <(echo -n 1)
	L_unittest_pipes <(L_map_get var b) <(echo -n 2)
	L_map_set var a 3
	L_unittest_pipes <(L_map_get var a) <(echo -n 3)
	L_unittest_pipes <(L_map_get var b) <(echo -n 2)
	L_unittest_checkexit 1 L_map_get var c
	L_unittest_checkexit 1 L_map_has var c
	L_unittest_checkexit 0 L_map_has var a
	L_map_set var allchars "$_L_allchars"
	L_unittest_pipes <(L_map_get var allchars) <(printf %s "$_L_allchars") "L_map_get var allchars"
	L_map_clear var allchars
	L_unittest_checkexit 1 L_map_get var allchars
	L_map_set var allchars "$_L_allchars"
	local s_a s_b s_allchars
	L_unittest_pipes <(L_map_keys var | sort) <(printf "%s\n" b a allchars | sort) "L_map_keys check"
	L_map_load var s_
	L_unittest_vareq s_a 3
	L_unittest_vareq s_b 2
	L_unittest_assert '[[ "$s_allchars" == "$_L_allchars" ]]'
}

# }}}
# L_argparsepy {{{

# see 'def usage()' below
L_argparsepy() {
	LC_ALL=C python - "$L_NAME" "$@" <<'EOF'
from __future__ import print_function
import argparse
import sys
import os
import io
import pathlib

# https://stackoverflow.com/questions/37572837/how-can-i-make-python-3s-print-fit-the-size-of-the-command-prompt
def get_terminal_columns():
	if sys.version_info.major == 3:
		import shutil
		return shutil.get_terminal_size().columns
	else:
		return 79
def eprint_autobreak(*args):
	import textwrap
	width = get_terminal_columns()  # Check size once to avoid rechecks per "paragraph"
	# Convert all args to strings, join with separator, then split on any newlines,
	# preserving line endings, so each "paragraph" wrapped separately
	for line in "".join(map(str, args)).splitlines(True):
		# Py3's print function makes it easy to print textwrap.wrap's result as one-liner
		eprint(*textwrap.wrap(line, width), sep="\n")

def eprint(*args, **kwargs):
	print(*args, file=sys.stderr, **kwargs)

def strchr(str, c):
	return str.find(c) == -1

fsencode = os.fsencode if sys.version_info.major == 3 else str
filetype = io.IOBase if sys.version_info.major == 3 else file

myusage = "Usage: L_argparse [variable_prefix] [argparse.ArgumentParser(arguments)...] -- [argparse.add_argument(arguments)... --]... -- <script_arguments>"
def errusage(*args):
	eprint_autobreak(
		myusage, "\n",
		"See L_argparse --help for more information.", "\n"
		"error: ", *args
	)
	sys.exit(1)

def usage():
	eprint_autobreak(myusage)
	eprint_autobreak("""
A special wrapper around python argparse to parse and export data to shell.
The arguments given to the script are split on '=' character and passe as a dictionary to argparse.ArgumentParser and
argparse.add_arguments functions. The first part before first -- is passed to ArgumetnParser, following parts are passed
to add_argument.

Example usage could look like the following:""")
	eprint("""
	set -- -n 123 -f /dev/stdout -p /var/log/ some arguments
	args=$(L_argparse PREFIX_ prog=myname description="This is just an example how to use this program." \\
				epilog="Written by Kamil Cukrowski and this example is free to use." -- \\
			-n dest=number type=int help="Give me a number" -- \\
			-f --file type=file_r help="This is read file" -- \\
			-o --ofile type=file_w help="This is output file" -- \\
			-g --ogile type=file_rw help="You can guess it" -- \\
			-p --database type=path help="This is a path to database" -- \\
			args nargs='+' help="Additional positional arguments" -- \\
			-- "$@"
	)
	ret=$?
	if ((ret == 0)); then
		echo "Help was displayed";
		exit
	elif ((ret == 1)); then
		echo "There was a parsing error";
		exit 1
	elif ((ret != 2)); then
		echo "There is an unhandled error that happened";
		exit 1
	fi
	# ret == 2
	eval "$args"
	echo "PREFIX_number=$PREFIX_number"
	echo "PREFIX_file=$PREFIX_file"
	echo "PREFIX_database=$PREFIX_database"
	echo "PREFIX_args=(${PREFIX_args[*]})"
	""")
	eprint_autobreak("Written by Kamil Cukrowski. Licensed jointly under MIT License and Beerware License.")
	sys.exit(0)

# Handle --help separately
if len(sys.argv) == 3 and sys.argv[2] in ("-h","--help"):
	usage()

class ArgparseBuilder:
	type_dict={
		"file_w": argparse.FileType('w'),
		"file_r":  argparse.FileType('r'),
		"file": argparse.FileType('rw') ,
		"file_": argparse.FileType('rw') ,
		"file_rw": argparse.FileType('rw'),
		"int": int,
		"float": float,
		# "ascii": ascii,
		"ord": ord,
		"open": open,
		"path": pathlib.Path,
		"pathlib.Path": pathlib.Path,
	}
	def convert_special(self, k, v):
		if k == "type":
			# Special strings - file_[rw] are handled specially to create argparse.FileType
			if v not in self.type_dict:
				errusage("unhandled type specified: {}={}".format(k, v))
			return self.type_dict[v]
		return v

	def __init__(self, argv):
		self.args = argv

	def is_our_option_separator(self, s):
		return s == "-" or s == "--"

	def build(self):
		# Our looping arguments state.
		a_args = []; a_kwargs = dict()
		# The first argument is the program name - it goes to argparse.ArgumentParser first argument.
		a_kwargs["prog"] = self.args.pop(0)
		# The second argument is expected to be prefix for variables.
		if not self.args:
			errusage("not enough arguments")
		# The first argument, if it's not --, is the variable prefix.
		a_prefix = b""
		if self.args and not self.is_our_option_separator(self.args[0]) and strchr(self.args[0], "="):
			a_prefix = fsencode(self.args.pop(0))
			if not self.args:
				errusage("not enough arguments")
		# From a list of arguments separated by == extract sublists
		# from sublists extract arguments with `=` and `-` assign twose to a dictionati in kwargs
		# other asing to array args
		# and then pass the first sublist to argparse.ArgumentParser
		# and other to argparse.add_argument
		# Such build the parsing. Parsing ends on empty list, ie. `-- --`.
		a_first = True
		for i in range(len(self.args)):
			arg = self.args[i]
			if not self.is_our_option_separator(arg):
				if strchr(arg, "=") or arg[0] == "-":
					a_args += [arg]
				else:
					(k, v) = arg.split('=', 1)
					a_kwargs[k] = self.convert_special(k, v)
			else:
				# eprint(a_first, a_args, a_kwargs)
				if a_first:
					a_first = False
					parser = argparse.ArgumentParser(*a_args, **a_kwargs)
				else:
					parser.add_argument(*a_args, **a_kwargs)
				a_args = []; a_kwargs = dict()
				if i + 1 >= len(self.args):
					errusage("double -- -- is missing in arguments")
				if self.is_our_option_separator(self.args[i + 1]):
					break
		if not self.is_our_option_separator(self.args[i]) and not self.is_our_option_separator(self.args[i + 1]):
			errusage("double -- -- is missing in arguments")
		# The rest of arguments are the arguments actually to be parsed
		self.args = self.args[i + 2:]
		return (a_prefix, parser.parse_args(self.args))


class ArgsOutputter:
	outbuf = b""

	def shellquote(self, s):
		if sys.version_info.major == 3:
			return b"'" + s.replace(b"'", b"'\\''") + b"'"
		else:
			return b"'" + str.replace(s, b"'", b"'\\''") + b"'"

	def write(self, *args):
		for i in args:
			self.outbuf += i

	def flush(self):
		if sys.version_info.major == 3:
			sys.stdout.buffer.write(self.outbuf)
		else:
			sys.stdout.write(self.outbuf)

	# Convert specific python type to a byte array for bash importing.
	conv_matrix = {
		bool: lambda val: b"true" if val else b"false",
		str: lambda val: fsencode(val),
		(int, float): lambda val: str(val).encode(),
		filetype: lambda val: fsencode(val.name),
		pathlib.Path: lambda val: fsencode(val.absolute()),
	}

	# Output "variable=value".
	def varprint(self, var, val):
		self.write(var.encode())
		self.write(b"=")
		str = b""
		for (t, l) in self.conv_matrix.items():
			if isinstance(val, t):
				str = self.shellquote(l(val))
				break
		if not str:
			errusage("Unhandled type= specified for {} option ".format(val), type(val))
		self.write(str)

	def parse(self, prefix, args):
		# For each argument parsed now in args, convert it and output
		# into a form eval-able in bash.
		for k in args.__dict__:
			v = args.__dict__[k]
			if v is not None:
				if isinstance(v, list):
					# Create a bash array from list
					self.write(prefix)
					self.write(k.encode())
					self.write(b"=(")
					for i in range(len(v)):
						self.varprint("[{}]".format(i), v[i])
						if i + 1 != len(v):
							self.write(b" ")
					self.write(b")\n")
				else:
					self.write(prefix)
					self.varprint(k, v)
					self.write(b"\n")
		return self

# The first argument is '-', so we start from second one.
(prefix, args) = ArgparseBuilder(sys.argv[1:]).build()
ArgsOutputter().parse(prefix, args).flush()
sys.exit(2)

EOF
	# "
}

L_argparsepy_exit_on_error() {
	local args
	args=$(L_argparsepy "$@")
	if (($? != 2)); then
		exit "$?"
	fi
	eval "$args"
}

# shellcheck disable=2016,2154
_L_argparsepy_test() {
	local arg="" num numbers
	local args
	args=$(
		L_argparsepy \
		description="description" epilog="epilog" -- \
		-n --num dest=num -- \
		numbers nargs="+" -- \
		-- -n $'\303(' 2 3
	)
	L_unittest_evalcheckexit 0 "(($? == 2))"
	eval "$args"
	L_unittest_pipes <(echo "$num") <(echo $'\303(')
	L_unittest_pipes <(printf "%s\n" "${numbers[@]}") <(printf "%s\n" 2 3)

	local allchars args allcharsnoslash
	allchars=$(seq 255 | xargs -d'\n' printf "%02x" | xxd -r -p)
	args=$(L_argparsepy -- \
		arg -- \
		-- "$allchars"
	)
	L_unittest_evalcheckexit 0 "(($? == 2))"
	eval "$args"
	L_unittest_pipes <(printf "%s" "$arg") <(printf "%s" "$allchars")

	allchars=$(seq 255 | xargs -d'\n' printf "%02x" | xxd -r -p)
	allcharsnoslash=$(tr -d '/' <<<"$allchars")

	args=$(L_argparsepy -- \
		arg nargs='+' -- \
		-- "$allchars" "$allchars" "'"
	)
	L_unittest_evalcheckexit 0 "(($? == 2))"
	eval "$args"
	L_unittest_pipes <(printf "%s\n" "${arg[@]}") <(printf "%s\n" "$allchars" "$allchars" "'")

	L_unittest_evalcheckexit 0 'L_argparsepy description=bb7895c0-1644-49a8-8499-472beec5b075 -- -- -h | grep -q bb7895c0-1644-49a8-8499-472beec5b075'
	L_unittest_evalcheckexit 1 L_argparsepy 2>/dev/null
	L_unittest_evalcheckexit 1 L_argparsepy -- 2>/dev/null
	L_unittest_evalcheckexit 0 L_argparsepy -- -- -h >/dev/null
	L_unittest_evalcheckexit 0 'L_argparsepy -- --; (($? == 2))'

	L_argparsepy_exit_on_error -- \
		-n --num -- \
		numbers nargs='+' -- \
		-- -n 123 2 3
	L_unittest_evalcheckexit 0 '((num == 123))'
	L_unittest_evalcheckexit 0 '((${numbers[0]} == 2))'
	L_unittest_evalcheckexit 0 '((${numbers[1]} == 3))'

	L_unittest_evalcheckexit 2 L_argparsepy -- \
		-q dest=_L_lib_loadonly action=store_true -- \
		-- -q '>/dev/null'

	(
		tmpd=$(mktemp -d)
		trap 'rm -r "$tmpd"' EXIT
		f="$tmpd/$allcharsnoslash"
		touch -- "$f"
		L_argparsepy_exit_on_error "PREFIX_" -- \
			-f --file type=file_w -- \
			-g --gfile type=file_w -- \
			-- -f "$f" -g /dev/stdout
		L_unittest_pipes <(echo "$PREFIX_gfile") <(echo /dev/stdout)
		L_unittest_pipes <(cat <<<"$PREFIX_file") <(cat <<<"$f")
	)

	L_argparsepy_exit_on_error "PREFIX_" -- \
			-n type=int -- \
			-- -n 123
	L_argparsepy_exit_on_error "PREFIX_" -- \
			-d type=path -- \
			-- -d /dev/

	L_argparsepy_exit_on_error PREFIX_ prog=myname description="This is just an example how to use this program." \
				epilog="Written by Kamil Cukrowski and this example is free to use." -- \
			-n dest=number type=int help="Give me a number" -- \
			-f --file type=file_r help="This is a file" -- \
			-o --ofile type=file_w help="This is output file" -- \
			-g --ogile type=file_rw help="You can guess it" -- \
			-p --database type=path help="This is a path to database" -- \
			args nargs='+' help="Additional positional arguments" -- \
			-- -n 123 -f /dev/stdout -p /var/log/ some arguments
	eval "$args"
	L_unittest_vareq PREFIX_number 123
	L_unittest_vareq PREFIX_file  /dev/stdout
	L_unittest_vareq PREFIX_database /var/log
	L_unittest_vareq PREFIX_args[0] some
	L_unittest_vareq PREFIX_args[1] arguments
	L_unittest_evalcheckexit 1 'L_isset PREFIX_ofile'
	L_unittest_evalcheckexit 1 'L_isset PREFIX_gfile'
}

# }}}
# L_argparse {{{

L_argparse() {
	# Arguments from pythona argparse.ArgumentParser() function
	local _L_p_prog="$L_name" _L_p_usage="" _L_p_description="" _L_p_epilog=""
	local _L_p_argument_default="" _L_p_add_help=1 _L_p_exit_on_error=1
	# Additional arguments for getopts and bash
	local _L_p_alternative=0 _L_p_exitatfirst=0 _L_p_prefix=""
	while (($#)); do
		case "$1" in
		prog=*|usage=*|description=*|epilog=*|argument_default=*|add_help=*|exit_on_error=*) ;&
		alternative=*|exitatfirst=*|prefix=*)
			case "${1%%=*}" in
			# booleans
			add_help|exit_on_error|alternative|exitatfirst)
				if L_is_true "${1#*=}"; then
					printf -v "_L_p_${1%%=*}" %s "1"
				else
					printf -v "_L_p_${1%%=*}" %s "0"
				fi
				;;
			*)
				printf -v "_L_p_${1%%=*}" %s "${1#*=}"
				;;
			esac
			;;
		*) break; ;;
		esac
		shift
	done
	#declare -p _L_p_prog _L_p_usage _L_p_description _L_p_epilog _L_p_argument_default _L_p_add_help _L_p_exit_on_error _L_p_alternative _L_p_exitatfirst _L_p_prefix
	local _L_p_tmp
	if _L_p_tmp=$(_L_argparse_in "$@"); then
		eval "$_L_p_tmp"
		return 0
	else
		local _L_p_ret=$?
		if ((_L_p_exit_on_error)); then
			exit "$((_L_p_ret == 10 ? 0 : _L_p_ret))"
		fi
		return "$_L_p_ret"
	fi
}

_L_argparse_in() {
	# functions 
	_L_argparse_argnext() {
		var="arg$(( argnext = ${argnext:-0} + 1 , argnext - 1 ))"
		L_map_init "$var"
	}
	#
	_L_argparse_argload() {
		a_arg=$1
		a_argnum=${1#arg}
		L_map_getv a_nargs "$1" nargs ''
		L_map_getv a_lopts "$1" lopts ''
		L_map_getv a_sopts "$1" sopts ''
		L_map_getv a_isopt "$1" isopt 0
		L_map_getv a_num "$1" num ''
		L_map_getv a_default "$1" default ''
		L_map_getv a_dest "$1" dest ''
		L_map_getv a_metavar "$1" metavar "$a_dest"
	}
	#
	_L_argparse_debug() {
		echo "argparse2:${BASH_LINENO[1]}: $*" >&2
	}
	_L_argparse_fatal() {
		echo "$L_name: $*" >&2
		exit 1
	}
	#
	# Generates the help description for the command.
	_L_argparse_fmt() {
		if L_cmd_exists fmt; then
			local tmp
			tmp="$(fmt -w "${@:2}" <<<"${!1}")"
			printf -v "$1" "%s" "$tmp"
		fi
	}
	_L_argparse_column() {
		if L_cmd_exists column && { column -V | grep -q util-linux; } 2>/dev/null; then
			local tmp
			tmp="$(column "${@:2}" <<<"${!1}")"
			printf -v "$1" %s "$tmp"
		fi
	}
	_L_argparse_help_internal() {
		cat <<EOF

Usage: L_argparse [ArgumentParser_option=value]... -- \\
		[ [-o]... [--longopt]... [add_argument_option=value]... -- ]... \\
		-- [arguments]...

This is a handy bash argument parser to mimic python argparse library. It
parses the it's arguments, then calls getopt(1) with prepared arguments, then
set's variables with proper names as given from options. 
It is a bash function and by default the function will exits the program on
error. Use exit_on_error=0 to disable that behavior.

ArgumentParser options:
	prog              Program name. default: \${0##*/}
	usage             Usage line
	description
	epilog
	argument_default  A string of **quoted** arguments in case nothing is passed.
		WARNING: argument_default value is passed to eval(1)!
	add_help          Ignored, TODO
	exit_on_error     Exit on error, it is enabled by default.
	alternative       Add '-a' to getopt(1) call
	exitatfirst       Add '+' to '-o' option to getopt(1) call
	prefix            Export variables with specified prefix

add_argument options:
	nargs       Can be one of::
		=0   - a flag, 1 or 0
		=1   - must have an option (default)
		='?' - zero or one argument (passes '::' to option to getopt(1))
		=+   - one or more arguments, results is array
		='*' - zero or more arguments, result is an array
		=234 - exactly 234 arguments (a number), result is an array
	default     Default value
	type        Can be one of:
		=int    - integer +([0-9])
		=float  - float +([0-9]).*([0-9])
		=file   - file for read and write
		=file_r - file for reading
		=file_w - file for writing
	help       Display this help on help string
	dest       Assign to this variable name (optionally prefixed with prefix)
	metaver    Variables name as displayed in help string
	choices    Ignored, TODO
	required   Ignored, use nargs

Example:
	# some_script.sh
	L_argparse \\
		prog=some_script \\
		description="This is a smple L_argparse invokation" \\
		suffix="This is licensed the same way as L_argparse" \\
		prefix=ARGS_ \\
		-- \\
		-o --opt  nargs=0 help="This is a sample option with name opt" -- \\
		-m --many nargs=+ help"This is a sample option with one or more values" -- \\
		-o --outfile dest=out default=/dev/stdout help="A sample option for default output file" -- \\
		numbers   nargs=2 help="Two numbers for positional arguments" -- \\
		operation nargs=1 help="A sample operation to do with the numbers" -- \\
		-- "\$@"
	echo "ARGS_opt=\$ARGS_opt"
	echo "ARGS_many=\$ARGS_many"
	echo "ARGS_out=\$ARGS_out"
	echo "ARGS_numbers=(\${ARGS_numbers[0]} \${ARGS_numbers[1]})"
	echo "ARGS_operation=\$ARGS_operation"

Written by Kamil Cukrowski 2021. Licensed jointly under MIT License and Beerware License.
EOF
		_L_argparse_fatal "$*"
	}

	_L_argparse_printhelp() {
		local fsopts uropts arg a_nargs a_isopt a_metavar post options poss tmp i usopts ulopts columns sep
		usopts="" # Short options in usage.
		ulopts="" # Long options in usage or options with required argument.
		arguments="" # List of argument names printed in usage.
		poss="" # Positional arguments description string.
		options="" # Options arguments descirption string.
		sep=$'\t'
		if ! columns=$(tput cols); then
			columns=0
		fi
		local a_nargs a_isopt a_help a_metavar l_defaults defaults
		for arg in $argit; do
			L_map_getv a_nargs "$arg" nargs
			L_map_getv a_isopt "$arg" isopt
			L_map_getv a_help "$arg" help ''
			L_map_getv a_metavar "$arg" metavar
			l_defaults=""
			if L_map_getv default "$arg" default && ((${#default} < 80)); then
				printf -v default "%q" "$default"
				l_defaults=" (default: $default)"
			fi
			#echo "$a_isopt $arg"
			if ((a_isopt)); then
				L_map_getv a_sopts "$arg" sopts
				# Convert 'a b c ' into '-a -b -c'
				l_sopts=${a_sopts:+-}${a_sopts// / -}
				l_sopts=${l_sopts% -}
				L_map_getv a_lopts "$arg" lopts
				# Convert 'abc def efg ' into '--abc --def --efg'
				l_lopts=${a_lopts:+--}${a_lopts// / --}
				l_lopts=${l_lopts% --}
				#
				l_optstr=${l_sopts}${l_lopts:+ }${l_lopts}
				ulopts+=" "
				options+=$'\n'"  $l_optstr"
				case "$a_nargs" in
				0) usopts+=${a_sopts// /}; ulopts+="[$l_lopts]";;
				'?') options+=" [${a_metavar}]"; ulopts+="[${l_optstr} [${a_metavar}]]" ;;
				'*') options+=" [${a_metavar}...]"; ulopts+="[${l_optstr} [${a_metavar}]]..." ;;
				'+') options+=" ${a_metavar}..."; ulopts+="[${l_optstr} ${a_metavar}]..." ;;
				[0-9]*)
					tmp=""; for ((i = 0; i < a_nargs; ++i)); do tmp+="${tmp:+ }$a_metavar"; done
					options+=" $tmp"
					ulopts+="$l_optstr $tmp"
					;;
				*) _L_argparse_fatal "nargs invalid value for $arg"; ;;
				esac
				options+=$'\t'"${a_help}${l_defaults}"
			else
				poss+=$'\n'"  "
				case "$a_nargs" in
				0) tmp=""; ;;
				'?') tmp="[${a_metavar}]" ;;
				'*') tmp="[${a_metavar}...]" ;;
				'+') tmp="${a_metavar}..." ;;
				+([0-9])) tmp=""; for ((i = 0; i < a_nargs; ++i)); do tmp+="${tmp:+ }$a_metavar"; done ;;
				*) _L_argparse_fatal "nargs invalid value for $arg: $a_nargs"; ;;
				esac
				arguments+=" $tmp"
				poss+="$tmp"$'\t'"${a_help}${l_defaults}"
			fi
		done
		# Add -h --help option to the options string.
		options+=$'\n'"  -h --help"$'\t'"Print this help and exit"
		#
		local default_epilog usage description epilog
		default_epilog="Written by Kamil Cukrowski $(printf "%(%Y)T"). Licensed jointly under MIT License and Beerware License."
		usage=${_L_p_usage:-$_L_p_prog${usopts:+ [-$usopts]}${ulopts}${arguments}}
		#
		# Remove leading and trailing newlines and remove tab in front from description.
		description="$_L_p_description"
		description=$'\n'"$description"
		description="${description//$'\n'+($'\t')/$'\n'}"
		description=${description##+($'\n')}
		description=${description%%+($'\n')}
		#
		epilog="${_L_p_epilog:="$default_epilog"}"
		#
		poss=${poss#$'\n'}
		options=${options#$'\n'}
		if ((columns > 20)); then
			_L_argparse_fmt usage "$((columns - 8))"
			usage=${usage//$'\n'/$'\n'        }
			_L_argparse_column poss -t -s "$sep" -o '  '
			_L_argparse_column options -t -s "$sep" -o '  '
			_L_argparse_fmt description "$((columns - 8))"
		fi
		cat <<EOF
Usage:  $usage
${poss:+
Positional arguments:
${poss}
}${options:+
Options:
${options}
}${description:+
$description
}${epilog:+
$epilog}
EOF
	}
	#
	set -euo pipefail -E -o functrace
	# Use stdout for logging, for simplicity. Output to fd3.
	exec 3>&1
	exec 1>&2
	: "${_L_p_prog:=$L_NAME}"
	#
	# Do add_argument() parsing
	# Parse first argument - it has to be -- from the parent call.
	if ((!$#)); then
		_L_argparse_help_internal "missing arguments"
	fi
	if [[ "$1" == -h || "$1" == --help ]]; then
		_L_argparse_help_internal
		exit 10
	fi
	if [[ "$1" != -- ]]; then
		_L_argparse_fatal "invalid arguments: $*"
	fi
	shift
	# Parse add_arguments variable list.
	while (($#)) && [[ "$1" != "--" ]]; do
		_L_argparse_argnext
		while (($#)); do
			case "$1" in
			--) shift; break; ;;
			-*[$' \v\r\t\n']*)
				_L_argparse_fatal "invalid option value has a whitespace in it: ${1}"
				;;
			--*)
				v="${1#--}"; 
				L_map_append "$var" lopts "$v "
				L_map_set "$var" isopt 1
				;;
			-*)
				v="${1#-}"
				if ((${#v} != 1)); then _L_argparse_fatal "Short option must be exactly 1 character: $1"; fi
				L_map_append "$var" sopts "$v "
				L_map_set "$var" isopt 1
				;;
			nargs=*|default=*|type=*|choices=*|required=*|help=*|metavar=*|dest=*)
				t=${1%%=*}
				v=${1#*=}
				L_map_set "$var" "$t" "$v"
				;;
			*)
				# valid variable name in dest is checked below.
				L_map_set "$var" dest "$1"
				;;
			esac
			shift
		done
	done
	if ((!$#)); then
		_L_argparse_fatal "not enough arguments - maybe missing double '--'?"
	fi
	if [[ "$1" != "--" ]]; then
		_L_argparse_fatal "missing double -- -- argument at: $*"
	fi
	shift
	#
	# Iterator over arguments for ease to use for loops
	argcnt=${argnext:-0}
	argit=""; for ((i = 0; i < argcnt; ++i)); do printf -v argit '%sarg%d ' "$argit" "$i"; done
	# Create short and long options for getopt.
	sopts=""
	lopts=""
	for arg in $argit; do
		L_map_getv a_sopts "$arg" sopts ''
		L_map_getv a_lopts "$arg" lopts ''
		# Set default destination if not set.
		if ! L_map_getv a_dest "$arg" dest; then
			# shellcheck disable=2086
			if ! a_dest=$(set -- $a_lopts $a_sopts; (($#)) && printf %s "$1"); then
				_L_argparse_fatal "argument number ${arg#arg} has no name - you have specify it's name or at least one option"
			fi
			L_map_set "$arg" dest "$a_dest"
		fi
		# Set default value of metavar from dest.
		if ! L_map_getv a_metavar "$arg" metavar; then
			a_metavar="$a_dest"
			L_map_set "$arg" metavar "$a_metavar"
		fi
		L_map_getv a_isopt "$arg" isopt 0
		# Set default arguments count.
		if ! L_map_getv a_nargs "$arg" nargs; then
			a_nargs="1"
			L_map_set "$arg" nargs "$a_nargs"
		fi
		# Create sopts and lopts for getopt from options.
		if ((a_isopt)); then
			case "$a_nargs" in
			+(0)) a_lopts=${a_lopts// /}; a_sopts=${a_sopts// /}; ;;
			'+'|1) a_lopts=${a_lopts// /:}; a_sopts=${a_sopts// /:}; ;;
			'?'|'*') a_lopts=${a_lopts// /::}; a_sopts=${a_sopts// /::}; ;;
			+([0-9])) _L_argparse_fatal "option $a_metavar: count of nargs not supported: $a_nargs"; ;;
			*) _L_argparse_fatal "option $a_metavar: invalid value of nargs: $a_nargs"; ;;
			esac
			sopts+=$a_sopts
			lopts+=${lopts:+,}$a_lopts
		fi
		# Set default value for action
		L_map_setdefault "$arg" action store
	done
	#_L_argparse_debug "$(declare -p sopts)"
	#_L_argparse_debug "$(declare -p lopts)"
	#
	# Parse arguments with getopt
	# If there are no arguments, assign them from default argument.
	if (($# == 0)) && [[ -n "${_L_p_argument_default:-}" ]]; then
		eval "set -- $_L_p_argument_default"
	fi
	if ((_L_p_exitatfirst)); then
		sopts="+$sopts"
	fi
	l_getopt=(getopt)
	if ((_L_p_alternative)); then
		l_getopt+=(-a)
	fi
	if args=$("${l_getopt[@]}" -n "$_L_p_prog" -o "${sopts}h" -l "help${lopts:+,}$lopts" -- "$@"); then :; else
		return "$?"
	fi
	eval "set -- $args"
	#
	#
	#
	_L_argparse_cb_action_init_store() {
		:
	}
	_L_argparse_cb_action_call_store() {
		:
	}
	_L_argparse_cb_action_init_store_const() {
		if L_map_has "$1" nargs; then _L_argparse_fatal "nargs not allowed"; fi
	}
	_L_argparse_cb_action_call_store_const() {
		if ! L_map_getv value "$1" const; then
			_L_argparse_fatal "option $a_metavar missing required argument: const"
		fi
	}
	_L_argparse_cb_action_init_store_true() {
		printf -v value false
	}
	_L_argparse_cb_action_call_store_true() {
		printf -v value true
	}
	_L_argparse_cb_action_init_store_false() {
		printf -v value true
	}
	_L_argparse_cb_action_call_store_false() {
		printf -v value false
	}
	_L_argparse_cb_action_init_store_1() {
		printf -v value 0
	}
	_L_argparse_cb_action_call_store_1() {
		printf -v value 1
	}
	_L_argparse_cb_action_init_store_0() {
		printf -v value 1
	}
	_L_argparse_cb_action_call_store_0() {
		printf -v value 0
	}
	_L_argparse_cb_action_init_store_count() {
		value=0
	}
	_L_argparse_cb_action_call_store_count() {
		printf -v value "$(($1 + 1))"
	}
	_L_argparse_cb_action_init_extern() {
		value=()
	}
	_L_argparse_cb_action_call_extend() {
		value+=("$@")
	}
	#
	for a_arg in $argit; do
		L_map_getv a_action "$a_arg" action
		f=_L_argparse_cb_action_init_$a_action
		if ! L_fn_exists "$f"; then
			_L_argparse_fatal "invalid action $a_action, function does not exists: $f"
		fi
		unset value
		"$f" "$a_arg"
		if value=$(declare -p value 2>/dev/null); then
			L_map_set "$a_arg" value "$value"
		fi
	done
	_L_argparse_setarg() {
		local a_nargs arg num
		arg="$1"
		L_map_getv a_nargs "$arg" nargs ''
		case "$a_nargs" in
		+(0))
			L_map_set "$arg" value "1"
			;;
		'?'|1)
			L_map_set "$arg" value "$2"
			return 1
			;;
		'+'|'*'|+([0-9]))
			L_map_getv num "$arg" num 0
			L_map_append "$arg" "value$num" "$2";
			L_map_set "$arg" num "$((num + 1))"
			case "$a_nargs" in [0-9]*)
				if ((num > a_nargs)); then
					_L_argparse_fatal "Too many arguments for option: $1"
				fi
			esac
			return 1
			;;
		*) _L_argparse_fatal "Invalid nargs: $1"; ;;
		esac
	}
	_L_argparse_setflagarg() {
		local type arg tmp j v
		type="$1"
		v="$2"
		for arg in $argit; do
			L_map_getv tmp "$arg" "${type}opts" ''
			for j in $tmp; do
				if [[ "$v" = "$j" ]]; then
					if ! _L_argparse_setarg "$arg" "$3"; then
						return 1
					fi
					return 0
				fi
			done
		done
		_L_argparse_fatal "Option $2 not found"
	}
	#_L_argparse_debug "$(args=("$@"); declare -p args)"
	while (($#)); do
		case "$1" in
		-h|--help) _L_argparse_printhelp; exit 10; ;;
		--) shift; break; ;;
		--*)
			if ! _L_argparse_setflagarg l "${1#--}" "${2:-}"; then shift; fi
			;;
		-*)
			if ! _L_argparse_setflagarg s "${1#-}" "${2:-}"; then shift; fi
			;;
		*) _L_argparse_fatal "Parsing error: $1"; ;;
		esac
		shift
	done
	#
	idx=-1
	idx_find_next_pos_arg() {
		for ((++idx; idx < argcnt; ++idx)); do
			arg=arg$idx
			local isopt
			L_map_getv isopt "$arg" isopt 0
			if ((!isopt)); then break; fi
		done
		if ((idx == argcnt)); then return 1; fi
		L_map_getv a_nargs "$arg" nargs ''
		L_map_getv a_metavar "$arg" metavar
		# _L_argparse_debug "$arg $a_nargs $a_metavar"
	}
	next=1
	while (($#)); do
		if ((next)); then
			next=0
			if ! idx_find_next_pos_arg; then
				break
			fi
		fi
		case "$a_nargs" in
		+(0))
			# Just accept with empty
			# _L_argparse_fatal "positional argument with 0 arguments"
			next=1
			set -- ignore "$@"
			;;
		'?'|1)
			L_map_set "$arg" value "$1"
			next=1
			;;
		'+'|'*'|+([0-9]))
			L_map_getv a_num "$arg" num 0
			L_map_append "$arg" "value$a_num" "$1"
			((a_num++)) ||:
			L_map_set "$arg" num "$a_num"
			#_L_argparse_debug "Assining $arg value$a_num=$1"
			case "$a_nargs" in [0-9]*)
				((next = a_num == a_nargs)) ||:
				# _L_argparse_debug "arg=$arg next=$next a_num=$a_num a_nargs=$a_nargs"
			esac
			;;
		*) _L_argparse_fatal "Invalid nargs: $nargs $1"; ;;
		esac
		shift
	done
	if (($#)); then
		_L_argparse_fatal "Too many positional arguments: $*"
	fi
	#
	_L_argparse_handle_type() {
		# all a_* variables are set
		# Because of getopt(1) limitation, empty values and unset are indestinguishingible.
		if [[ -z "$1" ]]; then
			return
		fi
		#
		case "$a_type" in
		bool)
			if L_is_true "$1"; then a_v=true; else a_v=false; fi
			;;
		boolint)
			if L_is_true "$1"; then a_v=1; else a_v=0; fi
			;;
		int)
			case "$1" in +([0-9])) ;;
				*) _L_argparse_fatal "value for $a_metavar is not an $a_type: $1";
			esac
			;;
		float)
			case "$1" in +([0-9]).*([0-9])|*([0-9]).+([0-9])) ;;
				*) _L_argparse_fatal "value for $a_metavar is not an $a_type: $1"
			esac
			;;
		file|file_rw)
			if [[ ! -r "$1" || ! -w "$1" ]]; then
				_L_argparse_fatal "file for $a_metavar could not be opened: $1"
			fi
			;;
		file_r)
			if [[ ! -r "$1" ]]; then
				_L_argparse_fatal "file for $a_metavar could not be opened for reading: $1"
			fi
			;;
		file_w)
			if [[ ! -w "$1" ]]; then
				_L_argparse_fatal "file for $a_metavar could not be opened for writing: $1"
			fi
			;;
		path|dir)
			if [[ ! -d "$1" ]]; then
				_L_argparse_fatal "path specified for $a_metavar is not a directory: $1"
			fi
			;;
		'') return; ;;
		*) _L_argparse_fatal "Invalid type for $a_metavar: $a_type"; ;;
		esac
	}
	#
	for arg in $argit; do
		a_isopt=0
		a_nargs=
		a_num=0
		a_default=
		a_metavar=
		a_type=
		L_map_load "$arg" a_ isopt nargs num default metavar type
		if ((!a_isopt)) && case "$a_nargs" in '?'|1) true ;; *) false ;; esac && [[ -z "$a_num" ]]; then
			_L_argparse_fatal "missing positional arguments for $a_metavar"
		fi
		unset value
		case "$a_nargs" in
		+(0)|1|'?')
			L_map_getv a_v "$arg" value "$a_default"
			_L_argparse_handle_type "$a_v"
			value="$a_v"
			;;
		*)
			case "$a_nargs" in
			+([0-9]))
				if ((a_num != a_nargs)); then
					_L_argparse_fatal "Not enough arguments for $a_metavar: $a_num != $a_nargs"
				fi
				;;

			'+')
				if ((a_num == 0)); then
					_L_argparse_fatal "Not enough arguments for $a_metavar: $a_num != 0"
				fi
				;;
			esac
			#
			value=()
			if [[ -n "$a_num" ]]; then
				for ((j = 0; j < a_num; ++j)); do
					L_map_getv a_v "$arg" "value$j"
					_L_argparse_handle_type "$a_v"
					value+=("$a_v")
				done
			else
				if [[ -n "$a_default" ]]; then
					mapfile -d ' ' -t tmp <<<"$a_default"
					for a_v in "${tmp[@]}"; do
						_L_argparse_handle_type "$a_v"
						value+=("$a_v")
					done				
				fi
			fi
			;;
		esac
		#
		L_map_getv dest "$arg" dest
		v=$(declare -p value)
		v=${v#*value=}
		printf "%s\n" "${_L_p_prefix}$dest=$v" >&3
	done
}

_L_argparse_test() {
	return # disabled
	local a pos1 pos2 bool more star mystar file f arg1 arg2

	a=(
		prog=this_is_prog
		description='This is a short description of the program'
		epilog='This is programs epilog'
		--
		-b --bool nargs=0 help="Example bool argument" --
		-o --one nargs=? type=file default=/dev/stdout help="Example one argument of file type" --
		-m --more nargs=+ type=int help="Example one or more arguments of type int" --
		-s --star nargs=* type=float dest=mystar help="Example zero or more arguments of type float" --
		dest=pos1 default=pos1default nargs=2 help="First positional argument repeated twice" metavar=N --
		dest=pos2 nargs=1 help="Second positional argument" metavar=M --
		--
	)

	# Test help string
	if true; then
		L_argparse exit_on_error=0 -- \
			-f --file -- \
			-f --flag nargs='?' -- \
			-p --param nargs='2' -- \
			-- --help
		L_unittest_cmd '' [ "$?" = 1 ]

		L_argparse exit_on_error=0 -- \
			-f --file default=filedefault -- \
			-f --flag nargs='?' default=flagdefault -- \
			-p --param nargs='0' default=paramdefault -- \
			-- --help
		L_unittest_cmd '' [ "$?" = 10 ]

		( L_argparse -- \
			dest=file -- \
			dest=pos1 metavar=N nargs='?' help="Example optional positional argument" -- \
			-- --help )
		L_unittest_cmd '' [ "$?" = 0 ]

		( L_argparse description=something -- dest=file -- -- --help )
		L_unittest_cmd '' [ "$?" = 0 ]

		( L_argparse "${a[@]}" --help )
		L_unittest_cmd '' [ "$?" = 0 ]

		( L_argparse "${a[@]:3}" --help )
		L_unittest_cmd '' [ "$?" = 0 ]
	fi
	# exit

	# taken from L_argparsepy_test ##############################################################################

	local num numbers
	L_argparse \
		description="description" epilog="epilog" -- \
		-n --num dest=num -- \
		numbers nargs="+" -- \
		-- -n $'\303(' 2 3
	L_unittest_cmd '' [ "$?" = 0 ]
	L_unittest_cmd '' [ "$num" = $'\303(' ]
	L_unittest_cmd '' [ "$(printf "%s\n" "${numbers[@]}")" = "$(printf "%s\n" 2 3)" ]

	local arg args allcharsnoslash
	L_argparse -- \
		arg -- \
		-- "$_L_allchars"
	L_unittest_cmd '' [ "$?" = 0 ]
	L_unittest_pipes <(printf %s "$arg") <(printf %s "$_L_allchars")

	allcharsnoslash=$(tr -d '/' <<<"$_L_allchars")

	L_argparse -- \
		arg nargs='+' -- \
		-- "$_L_allchars" "$_L_allchars" "'"
	L_unittest_pipes <(printf "%s\n" "${arg[@]}") <(printf "%s\n" "$_L_allchars" "$_L_allchars" "'")


	L_unittest_evalcheckexit 0 'L_argparse description=bb7895c0-1644-49a8-8499-472beec5b075 -- -- -h 2>&1 | grep -q bb7895c0-1644-49a8-8499-472beec5b075'
	L_unittest_evalcheckexit 1 '( L_argparse 2>/dev/null )'
	L_unittest_evalcheckexit 1 '( L_argparse -- 2>/dev/null )'
	L_unittest_evalcheckexit 0 '( L_argparse -- -- -h 2>/dev/null )'
	L_unittest_evalcheckexit 0 '( L_argparse -- -- 2>/dev/null )'

	L_argparse -- \
		-n --num -- \
		numbers nargs='+' -- \
		-- -n 123 2 3
	L_unittest_cmd '' [ "$?" = 0 ]
	L_unittest_cmd '' [ "$num" = 123 ]
	L_unittest_cmd '' [ "${numbers[0]}" = 2 ]
	L_unittest_cmd '' [ "${numbers[1]}" = 3 ]

	(
		tmpd=$(mktemp -d)
		trap 'rm -r "$tmpd"' EXIT
		f="$tmpd/$allcharsnoslash"
		touch -- "$f"
		L_argparse prefix="PREFIX_" -- \
			-f --file type=file_w -- \
			-g --gfile type=file_w -- \
			-- -f "$f" -g /dev/stdout
		L_unittest_cmd '' [ "$?" = 0 ]
		L_unittest_eq "$PREFIX_gfile" /dev/stdout
		L_unittest_eq "$PREFIX_file" "$f"
	)

	local PREFIX_n
	L_argparse prefix="PREFIX_" -- \
			-n type=int -- \
			-- -n 123
	L_unittest_cmd '' [ "$?" = 0 ]
	L_unittest_n "$PREFIX_d" "123"

	local PREFIX_d
	L_argparse prefix="PREFIX_" -- \
			-d type=path -- \
			-- -d /dev/
	L_unittest_eq "$?" 0
	L_unittest_eq "$PREFIX_d" "/dev/"

	L_argparse prefix=PREFIX_ prog=myname description="This is just an example how to use this program." \
				epilog="Written by Kamil Cukrowski and this example is free to use." -- \
			-n dest=number type=int help="Give me a number" -- \
			-f --file type=file_r help="This is a file" -- \
			-o --ofile type=file_w help="This is output file" -- \
			-g --ogile type=file_rw help="You can guess it" -- \
			-p --database type=path help="This is a path to database" -- \
			args nargs='+' help="Additional positional arguments" -- \
			-- -n 123 -f /dev/stdout -p /var/log/ some arguments
	L_unittest_cmd '' [ "$?" = 0 ]
	L_unittest_vareq PREFIX_number 123
	L_unittest_vareq PREFIX_file  /dev/stdout
	L_unittest_vareq PREFIX_database /var/log/ # difference to python argparse
	L_unittest_vareq PREFIX_args[0] some
	L_unittest_vareq PREFIX_args[1] arguments
	L_unittest_evalcheckexit 1 'L_isset PREFIX_ofile'
	L_unittest_evalcheckexit 1 'L_isset PREFIX_gfile'

	###############################################################################	`


	uuid=af61f100-1370-46f3-ae59-3ebfcc950464
	L_unittest_checkexit 10 L_argparse exit_on_error=0 prog=$uuid -- -f --file -- -- --help >/dev/null
	L_unittest_checkexit 10 L_argparse exit_on_error=0 prog=$uuid -- -f --file -- -- -h >/dev/null
	L_unittest_pipes <(L_argparse prog=$uuid -- -f --file -- -- --help 2>&1 | grep -ow "$uuid") <(echo "$uuid")
	
	L_unittest_checkexit 0 L_argparse alternative=1 -- -f --file -- -- -file arg1
	L_unittest_vareq file arg1
	unset file

	L_unittest_checkexit 0 L_argparse exitatfirst=1 -- -f -- dest=arg1 nargs=+ -- -- -f farg arg1 -f
	L_unittest_vareq f farg
	unset f
	L_unittest_vareq arg1[0] arg1 
	L_unittest_vareq arg1[1] -f
	unset arg1

	L_unittest_checkexit 0 L_argparse -- -f --file type=file -- -- -f /dev/stdout
	L_unittest_vareq file /dev/stdout
	unset file
	L_unittest_checkexit 1 L_argparse exit_on_error=0 -- -f --file type=file_w -- -- -f /doesnotexists
	L_unittest_checkexit 1 L_argparse exit_on_error=0 -- -f --file type=file_w -- -- -f /bin/ls
	L_unittest_checkexit 0 L_argparse -- -f --file type=file_w default=/dev/stdout -- --
	L_unittest_vareq file /dev/stdout
	unset file
	L_unittest_checkexit 1 L_argparse exit_on_error=0 -- -f --file type=file_r default=/doesnotexists -- --
	L_unittest_checkexit 0 L_argparse exit_on_error=0 argument_default="-f /dev/stdout" -- -f --file type=file_r default=/doesnotexists -- --
	L_unittest_vareq file /dev/stdout
	unset file

	_L_argparse_test2() {
		L_unittest_checkexit "$1" L_argparse "${a[@]}" "${@:2}"
	}
	_L_argparse_test2 0 -m1 -m2 -m3 -b -- a b c
	L_unittest_vareq bool 1
	L_unittest_vareq more[0] 1
	L_unittest_vareq more[1] 2
	L_unittest_vareq more[2] 3
	L_unittest_cmd '' [ "${#more[@]}" = 3 ]
	L_unittest_vareq pos1[0] a
	L_unittest_vareq pos1[1] b
	L_unittest_cmd '' [ "${#pos1[@]}" = 2 ]
	L_unittest_vareq pos2 c
}

# }}}
# lib_lib functions {{{

_L_lib_name=${BASH_SOURCE##*/}

_L_lib_lib_error() {
	echo "$_L_lib_name: ERROR: $*" >&2
}

_L_lib_lib_fatal() {
	_L_lib_lib_error "$@"
	exit 3
}

_L_lib_lib_list_prefix_functions() {
	L_list_functions_with_prefix "$L_prefix"
}

if ! L_fn_exists L_cb_usage_usage; then L_cb_usage_usage() {
	echo "Usage:  $L_name <COMMAND> [OPTIONS]"
}; fi

if ! L_fn_exists L_cb_usage_desc; then L_cb_usage_desc() {
	:;
}; fi

if ! L_fn_exists L_cb_usage_footer; then L_cb_usage_footer() {
	echo 'Written by Kamil Cukrowski. Licensed jointly under MIT License and Beeware License'
}; fi

# shellcheck disable=2046
_L_lib_lib_their_usage() {
	if L_function_exists L_cb_usage; then
		L_cb_usage $(_L_lib_lib_list_prefix_functions)
		return
	fi
	local a_usage a_desc a_cmds a_footer
	a_usage=$(L_cb_usage_usage)
	a_desc=$(L_cb_usage_desc)
	a_cmds=$(
		{
			for f in $(_L_lib_lib_list_prefix_functions); do
				desc=""
				if L_function_exists L_cb_"$L_prefix$f"; then
					L_cb_"$L_prefix$f" "$f" "$L_prefix"
				fi
				echo "$f${desc:+$'\01'}$desc"
			done
			echo "-h --help"$'\01'"print this help and exit"
			echo "--bash-completion"$'\01'"generate bash completion to be eval'ed"
		} | {
			if L_cmd_exists column && column -V 2>/dev/null | grep -q util-linux; then
				column -t -s $'\01' -o '   '
			else
				sed 's/#/    /'
			fi
		} | sed 's/^/  /'
	)
	a_footer=$(L_cb_usage_footer)
	cat <<EOF
${a_usage}

${a_desc:-}${a_desc:+

}Commands:
$a_cmds${a_footer:+

}${a_footer:-}
EOF
}

_L_lib_lib_show_best_match() {
	if tmp=$(
		_L_lib_lib_list_prefix_functions |
		if L_hash fzf; then
			fzf -0 -1 -f "$1"
		else
			grep -F "$1"
		fi
	) && [[ -n "$tmp" ]]; then
		echo
		echo "The most similar commands are"
		# shellcheck disable=2001
		<<<"$tmp" sed 's/^/\t/'
	fi >&2
}

# https://stackoverflow.com/questions/14513571/how-to-enable-default-file-completion-in-bash
# shellcheck disable=2207
_L_do_bash_completion() {
	if [[ "$(LC_ALL=C type -t -- "_L_cb_bash_completion_$L_NAME" 2>/dev/null)" = function ]]; then
		"_L_cb_bash_completion_$L_NAME" "$@"
		return
	fi
    if ((COMP_CWORD == 1)); then
        COMPREPLY=($(compgen -W "${cmds[*]}" -- "${COMP_WORDS[1]}"))
		# add trailing space to each
        #COMPREPLY=("${COMPREPLY[@]/%/ }")
    else
		COMPREPLY=()
    fi
}

# shellcheck disable=2120
_L_lib_lib_bash_completion() {
	local tmp cmds
	tmp=$(_L_lib_lib_list_prefix_functions)
	mapfile -t cmds <<<"$tmp"
	local funcname
	funcname=_L_bash_completion_$L_NAME
	eval "$funcname() {
		$(declare -p cmds L_NAME)"'
		_L_do_bash_completion "$@"
	}'
	declare -f _L_do_bash_completion "$funcname"
	printf "%s" "complete -o bashdefault -o default -F"
	printf " %q" "$funcname" "$0" "$L_NAME"
	printf '\n'
}

_L_lib_lib_unittests_run() {
	if (($# < 2)); then return; fi
	if [[ "$1" != "--test" ]]; then return; fi
	L_assert "(($# <= 3))" "too many arguments for --test"
	local mode repeat=0
	mode=${2:-}
	case "$mode" in +([0-9])-*)
		repeat=${mode%%-*}
		mode=${mode#+([0-9])-}
	esac
	if [[ "$mode" == time_all-* ]]; then
		L_time_all "$0" --test="50-${mode#time_all-}"
		exit
	fi
	tests=$(
		compgen -A function |
		grep -x '_L_.*_test' |
		grep "${mode:-.*}" ||:
	)
	if [[ -z "$tests" ]]; then
		L_fatal "No tests matched with $mode"
	fi
	local test i
	if ((repeat == 0)); then
		for test in $tests; do "$test"; done
	else
		for test in $tests; do
			for ((i = 0; i < repeat; ++i)); do
				"$test"
			done
		done >/dev/null 2>/dev/null
	fi	
	exit "${_L_unittest_result:-5}"
}

_L_lib_lib_usage() {
	cat <<EOF
Usage:
      . $_L_lib_name [options] -q
      . $_L_lib_name [options] <prefix> "\$@"
	  $_L_lib_name --test

A library to be called from other libraries. This is a simple script to
allow me to write simple reusable programs with bash completion and much
more TODO!

Usage example:

	# script.sh
	LIB_prefix_some_func() {
		desc="this func does that"
	}
    prefix_some_func() {
		echo 'yay!'
	}
    prefix_some_other_func() {
		echo 'not yay!'
	}
	source $_L_lib_name 'prefix_' "\$@"

Then you can enter from command line:

	script.sh some_func

You can import bash completion for the script with:

	eval "\$(script.sh --bash-completion)"

Options:
	-L   Drop L_ prefix on some functions
	-q   Only import library - do not parse arguments
	-l   Both -L and -q

Written by Kamil Cukrowski 2020.
Licensed jointly under Beerware License and MIT License.
EOF
}

# }}}
# Library end {{{
fi
# }}}
# lib_lib main {{{

# Easier to use library - drop L_ prefix on some functions if -L argument is passed
_L_lib_lib_args=$(getopt -n "$L_NAME:$_L_lib_name" -o +Llqha -l help,test:: -- "$@") || return 1
eval "set -- $_L_lib_lib_args"
unset _L_lib_lib_args
_L_lib_loadonly=0
_L_lib_help=0
_L_argparse=0
while (($#)); do
	case "$1" in
	-L) _L_lib_drop_L_prefix; ;;
	-q) _L_lib_loadonly=1; ;;
	-l) _L_lib_drop_L_prefix; _L_lib_loadonly=1; ;;
	-a) _L_argparse=1; ;;
	-h|--help) _L_lib_help=1; ;;
	--test) break; ;;
	--) shift; break; ;;
	*) L_fatal "$_L_lib_name: Internal error when parsing arguments"; ;;
	esac
	shift
done

if ! L_am_I_sourced; then
	_L_lib_lib_unittests_run "$@"
	_L_lib_lib_usage
	if ((_L_lib_help)); then exit 0; fi
	_L_lib_lib_fatal "Script $_L_lib_name has to be sourced!"
	exit 1
fi

if ((_L_lib_loadonly)); then
	if (($#)); then L_warning "Do not pass arguments with -q option"; fi
	unset _L_lib_loadonly
	return
fi
unset _L_lib_loadonly

if (($# == 0)); then _L_lib_lib_fatal "prefix argument missing"; fi
L_prefix=$1
case "$L_prefix" in
(-*) _L_lib_lib_fatal "prefix argument cannot start with -"; ;;
("") _L_lib_lib_fatal "prefix argument is empty"; ;;
esac
shift

if L_fn_exists "L_cb_parse_args"; then
	unset L_cb_args
	L_cb_parse_args "$@"
	if ! L_var_isset L_cb_args; then L_error "L_cb_parse_args did not return L_cb_args array"; fi
	# shellcheck disable=2154
	set -- "${L_cb_args[@]}"
elif ((_L_argparse)); then
	_L_tmps=()
	while (($#)); do
		if [[ "$1" == '--' ]]; then
			shift
			break
		fi
		_L_tmps+=("$1")
		shift
	done
	L_argparse "${_L_tmps[@]}" \
		-q --quiet callback='L_logmask=61' -- \
		-v --verbose dest=L_logmask action=store_const const=255 --
		"$@"
else
	case "${1:-}" in
	(--bash-completion)
		_L_lib_lib_bash_completion
		return
		exit
		;;
	(-h|--help)
		_L_lib_lib_their_usage "$@"
		return
		exit
		;;
	esac
fi

if (($# == 0)); then
	if ! L_fn_exists "${L_prefix}DEFAULT"; then
		_L_lib_lib_their_usage "$@"
		L_error "Command argument missing."
		exit 1
	fi
fi
L_mode="${1:-DEFAULT}"
shift
if ! L_function_exists "$L_prefix$L_mode"; then
	L_error "Unknown command: '$L_mode'. See '$L_NAME --help'."
	_L_lib_lib_show_best_match "$L_mode"
	exit 1
fi
"$L_prefix$L_mode" "$@"

# }}}

# vim: foldmethod=marker

