#!/bin/bash

L_name=${0##*/}

L_dir=${0%/*}

L_dryrun=false

L_log() {
	echo "$L_name: $*" >&2
}

L_error() {
	L_log "ERROR:" "$@"
}

L_fatal() {
	L_error "$*"
	exit 2
}

L_command_exists() {
	command -v "$1" >/dev/null 2>&1
}

L_hash() {
	hash "$1" >/dev/null 2>&1
}

L_logrun() {
	L_log "+" "$@"
	"$@"
}

L_run() {
	L_log "+" "$@"
	if ! "$L_dryrun"; then
		"$@"
	fi
}

###############################################################################

,lib_lib_usage() {
	cat <<'EOF'
Usage:
	# script.sh
	LIB_prefix_some_func() {
		desc="this func does that"
	}		
    prefix_some_func() {
		echo 'yay!'
	}
	source ,lib_lib 'prefix_' "$@"

	# then from command line:
	eval "$(script.sh --bash-autocompletion)"
	script.sh some_func


A library to be called from other libraries
This is a simple script to allow me to write:
- simple reusable programs
- with bash completion
and much more TODO!

Written by Kamil Cukrowski 2020
EOF
}

,lib_lib_error() {
	echo ",lib_lib: ERROR: $*" >&2
}

,lib_lib_fatal() {
	,lib_lib_error "$@"
	exit 3
}

,lib_lib_list_functions() {
	declare -F -p | LC_ALL=C sed '/^declare -f '"$1"'/!d; s///' | LC_ALL=C sort
}

,lib_lib_list_prefix_functions() {
	,lib_lib_list_functions "$L_prefix"
}

,lib_lib_function_exists() {
	[[ -n "$(LC_ALL=C type -t -- "$1")" && "$(LC_ALL=C type -t -- "$1")" = function ]]
}

,lib_lib_their_usage() {
	if ,lib_lib_function_exists usage; then
		usage "$(,lib_lib_list_prefix_functions)"
		return 
	fi
	cat <<EOF
Usage: $L_name <COMMAND> [OPTIONS]

Commands:
$(
	{
		for f in $(,lib_lib_list_prefix_functions); do
			desc=""
			if ,lib_lib_function_exists LIB_"$L_prefix$f"; then
				LIB_"$L_prefix$f" "$f" "$L_prefix"
			fi
			echo "$f${desc:+#}$desc"
		done
		echo "--bash-completion#Generate bash completion to be eval'ed."
	} |
	if hash column 2>/dev/null >&2; then
		column -t -s '#' -o ' - '
	else
		sed 's/#/ - /'
	fi | sed 's/^/  /'
)

EOF
}

,lib_lib_show_best_match() {
	if L_hash fzf &&
			tmp=$(,lib_lib_list_prefix_functions | fzf -0 -1 -f "$1") &&
			[[ -n "$tmp" ]]; then
		echo "   Maybe you meant: $tmp ?" >&2
	fi
}

###############################################################################

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	,lib_lib_usage
	,lib_lib_fatal "Not sourced"
fi
if (($# == 0)); then ,lib_lib_fatal "called with less then one argument"; fi
L_prefix=$1
shift
if [[ -z "$L_prefix" ]]; then ,lib_lib_fatal "first argument is empty"; fi

if [[ "${1:-}" = '--bash-completion' ]]; then
	printf "%q\n" complete -W "$(,lib_lib_list_prefix_functions | paste -sd' ')" "$0" "$(basename -- "$0")" | paste -sd' '
	exit
fi
if (($# == 0)); then
	,lib_lib_their_usage "$@"
	exit
fi

L_mode=$1
shift
if ! ,lib_lib_function_exists "$L_prefix$L_mode"; then
	,lib_lib_their_usage
	,lib_lib_error "Unknown command: $L_mode"
	,lib_lib_show_best_match "$L_mode"
	exit
fi
"$L_prefix$L_mode" "$@"



