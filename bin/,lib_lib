#!/bin/bash
# This is a collection of libraries that I seem to use over and over
# again and again inm every script I write.
# It's here to simplify my use of it.
# Written by Kamil Cukrowski
# Licensed jointly under MIT License and Beerware License
# SPDX-License-Identifier: MIT + Beerware

# shellcheck disable=SC2034

# Library start {{{

shopt -s extglob

# Source only once, to speed up
if [[ -z "${L_LIB_LIB_SOURCED:-}" ]]; then
L_LIB_LIB_SOURCED=true
readonly L_LIB_LIB_SOURCED

# }}}
# Globals {{{

L_name=${0##*/}
L_dir=${0%/*}
L_NAME="$L_name"
L_DIR="$L_dir"
readonly L_NAME L_DIR

# }}}
# Colors {{{

L_BOLD=$'\E[1m'
L_BRIGHT=$'\E[1m'
L_DIM=$'\E[2m'
L_FAINT=$'\E[2m'
L_STANDOUT=$'\E[3m'
L_UNDERLINE=$'\E[4m'
L_BLINK=$'\E[5m'
L_REVERSE=$'\E[7m'
L_CONCEAL=$'\E[8m'
L_HIDDEN=$'\E[8m'
L_CROSSEDOUT=$'\E[9m'

L_FONT0=$'\E[10m'
L_FONT1=$'\E[11m'
L_FONT2=$'\E[12m'
L_FONT3=$'\E[13m'
L_FONT4=$'\E[14m'
L_FONT5=$'\E[15m'
L_FONT6=$'\E[16m'
L_FONT7=$'\E[17m'
L_FONT8=$'\E[18m'
L_FONT9=$'\E[19m'

L_FRAKTUR=$'\E[20m'
L_DOUBLE_UNDERLINE=$'\E[21m'
L_NODIM=$'\E[22m'
L_NOSTANDOUT=$'\E[23m'
L_NOUNDERLINE=$'\E[24m'
L_NOBLINK=$'\E[25m'
L_NOREVERSE=$'\E[27m'
L_NOHIDDEN=$'\E[28m'
L_REVEAL=$'\E[28m'
L_NOCROSSEDOUT=$'\E[29m'

L_BLACK=$'\E[30m'
L_RED=$'\E[31m'
L_GREEN=$'\E[32m'
L_YELLOW=$'\E[33m'
L_BLUE=$'\E[34m'
L_MAGENTA=$'\E[35m'
L_CYAN=$'\E[36m'
L_LIGHT_GRAY=$'\E[37m'
L_DEFAULT=$'\E[39m'
L_FOREGROUND_DEFAULT=$'\E[39m'

L_BACKGROUND_BLUE=$'\E[44m'
L_BACKGROUND_CYAN=$'\E[46m'
L_BACKGROUND_DEFAULT=$'\E[49m'
L_BACKGROUND_GREEN=$'\E[42m'
L_BACKGROUND_LIGHT_GRAY=$'\E[47m'
L_BACKGROUND_MAGENTA=$'\E[45m'
L_BACKGROUND_YELLOW=$'\E[43m'
L_B_BLACK=$'\E[40m'
L_B_BLUE=$'\E[44m'
L_B_CYAN=$'\E[46m'
L_B_GREEN=$'\E[42m'
L_B_LIGHT_GRAY=$'\E[47m'
L_B_MAGENTA=$'\E[45m'
L_B_RED=$'\E[41m'
L_B_YELLOW=$'\E[43m'

L_FRAMED=$'\E[51m'
L_ENCIRCLED=$'\E[52m'
L_OVERLINED=$'\E[53m'
L_NOENCIRCLED=$'\E[54m'
L_NOFRAMED=$'\E[54m'
L_NOOVERLINED=$'\E[55m'

L_DARK_GRAY=$'\E[90m'
L_LIGHT_RED=$'\E[91m'
L_LIGHT_GREEN=$'\E[92m'
L_LIGHT_YELLOW=$'\E[93m'
L_LIGHT_BLUE=$'\E[94m'
L_LIGHT_MAGENTA=$'\E[95m'
L_LIGHT_CYAN=$'\E[96m'
L_WHITE=$'\E[97m'

L_BACKGROUND_DARK_GRAY=$'\E[100m'
L_BACKGROUND_LIGHT_BLUE=$'\E[104m'
L_BACKGROUND_LIGHT_CYAN=$'\E[106m'
L_BACKGROUND_LIGHT_GREEN=$'\E[102m'
L_BACKGROUND_LIGHT_MAGENTA=$'\E[105m'
L_BACKGROUND_LIGHT_RED=$'\E[101m'
L_BACKGROUND_LIGHT_YELLOW=$'\E[103m'
L_BACKGROUND_WHITE=$'\E[107m'

L_B_DARK_GRAY=$'\E[100m'
L_B_LIGHT_BLUE=$'\E[104m'
L_B_LIGHT_CYAN=$'\E[106m'
L_B_LIGHT_GREEN=$'\E[102m'
L_B_LIGHT_MAGENTA=$'\E[105m'
L_B_LIGHT_RED=$'\E[101m'
L_B_LIGHT_YELLOW=$'\E[103m'
L_B_WHITE=$'\E[107m'

L_RESET=$'\E(B\E[m'

L_ansi_up() { printf $'\E[%dA' "$@"; }
L_ansi_down() { printf $'\E[%dB' "$@"; }
L_ansi_right() { printf $'\E[%dC' "$@"; }
L_ansi_left() { printf $'\E[%dD' "$@"; }
L_ansi_next_line() { printf $'\E[%dE' "$@"; }
L_ansi_prev_line() { printf $'\E[%dF' "$@"; }
L_ansi_set_column() { printf $'\E[%dG' "$@"; }
L_ansi_set_position() { printf $'\E[%d;%dH' "$@"; }
L_ansi_clear_screen_until_end() { printf '\E[0J'; }
L_ansi_clear_screen_until_beginning() { printf '\E[1J'; }
L_ansi_clear_screen() { printf '\E[2J'; }
L_ansi_clear_line_until_end() { printf '\E[0K'; }
L_ansi_clear_line_until_beginning() { printf '\E[1K'; }
L_ansi_clear_line() { printf '\E[2K'; }
L_ansi_save_position() { printf '\E7'; }
L_ansi_restore_position() { printf '\E8'; }

L_lcolor=
L_lcolor_enable() { L_lcolor=yes; }
L_lcolor_disable() { L_lcolor=; }
if [ -t 1 ]; then
	L_lcolor_enable
fi
# Use: echo "${L_color:+$L_RED}someoutput${L_color:+$L_RESET}"

# }}}
# Loglevel library {{{

L_LOG_EMERG=0
L_LOG_ALERT=1
L_LOG_CRIT=2
L_LOG_ERR=3
L_LOG_WARNING=4
L_LOG_NOTICE=5
L_LOG_INFO=6
L_LOG_DEBUG=7
L_LOG_PRIMASK=7
L_LOG_DEBUG2=8
L_LOG_DEBUG3=9
L_LOG_PRIORITY_NAMES=(
	[L_LOG_EMERG]="emerg"
	[L_LOG_ALERT]="alert"
	[L_LOG_CRIT]="crit"
	[L_LOG_ERR]="err"
	[L_LOG_WARNING]="warning"
	[L_LOG_NOTICE]="notice"
	[L_LOG_INFO]="info"
	[L_LOG_DEBUG]="debug"
)
L_LOG_COLORS=(
	[L_LOG_EMERG]="${L_BOLD}${L_RED}"
	[L_LOG_ALERT]="${L_BOLD}${L_RED}"
	[L_LOG_CRIT]="${L_BOLD}${L_RED}"
	[L_LOG_ERR]="${L_BOLD}${L_RED}"
	[L_LOG_WARNING]="${L_BOLD}${L_YELLOW}"
	[L_LOG_NOTICE]="${L_BOLD}${L_CYAN}"
	[L_LOG_INFO]=""
	[L_LOG_DEBUG]=""
)

L_lmask=128
L_lmask_isallowed() {   (( !(L_lmask & (1 << $1) ) )); }
L_lmask_isblocked() {   ((  (L_lmask & (1 << $1) ) )); }
L_lmask_allow() {       (( L_lmask &= ~(1 << $1) )) || :; }
L_lmask_block() {       (( L_lmask |=  (1 << $1) )) || :; }
L_lmask_allow_below() { (( L_lmask &= ~((1 << $1) - 1) )) || :; }
L_lmask_block_below() { (( L_lmask |=  (1 << $1) - 1 )) || :; }

L_logname=
L_log_set_backend_printf() {
	L_logl_backend() {
		printf "%s\n" "${L_logname:-$L_name}: ${*:2}" >&2
	}
}
L_log_set_backend_logger() {
	L_logl_backend() {
		logger -s -e -t "${L_logname:-$L_name}" -p "$1" "${*:2}"
	}
}
L_log_set_backend_printf

# shellcheck disable=SC2140
L_logl() {
	if L_lmask_isallowed "$1"; then
		L_logl_backend "$1" \
"${L_lcolor:+${L_LOG_COLORS[$1]}}"\
"${L_LOG_PRIORITY_NAMES[$1]:+${L_LOG_PRIORITY_NAMES[$1]}}"\
"${L_lcolor:+${L_RESET}}: ${*:2}"
	fi
}

L_log() {
	if L_lmask_isallowed "L_LOG_INFO"; then
		L_logl_backend "$L_LOG_INFO" "$@"
	fi
}

L_emerg() { L_logl "L_LOG_EMERG" "$@"; }
L_alert() { L_logl "L_LOG_ALERT" "$@"; }
L_crit() { L_logl "L_LOG_CRIT" "$@"; }
L_err() { L_logl "L_LOG_ERR" "$@"; }
L_warning() { L_logl "L_LOG_WARNING" "$@"; }
L_notice() { L_logl "L_LOG_NOTICE" "$@"; }
L_info() { L_logl "L_LOG_INFO" "$@"; }
L_debug() { L_logl "L_LOG_DEBUG" "$@"; }
L_panic() { L_logl "L_LOG_PANIC" "$@"; }
L_error() { L_logl "L_LOG_ERR" "$@"; }
L_warn() { L_logl "L_LOG_WARNING" "$@"; }

# shellcheck disable=SC2016
_L_loglibrary_test() {
	(
		set -euo pipefail
		u=17070a0d-8ebf-465b-b630-281e89fd6df2
		L_unittest_assert '! L_debug "$u" 2>&1 | grep -q "$u"'
		L_unittest_assert 'L_info g "$u" 2>&1 | grep -q "$u"'
		L_unittest_assert 'L_lmask_isblocked L_LOG_DEBUG'
		L_unittest_assert 'L_lmask_isallowed L_LOG_INFO'
		L_unittest_assert 'L_lmask_block L_LOG_INFO'
		L_unittest_assert 'L_lmask_allow L_LOG_DEBUG'
		L_unittest_assert 'L_lmask_isallowed L_LOG_DEBUG'
		L_unittest_assert 'L_lmask_isblocked L_LOG_INFO'
		L_unittest_assert '! L_lmask_isblocked L_LOG_DEBUG'
		L_unittest_assert '! L_lmask_isallowed L_LOG_INFO'
		L_unittest_assert 'L_lmask_block L_LOG_DEBUG'
		L_unittest_assert 'L_lmask_isblocked L_LOG_DEBUG'
	)
}

# }}}
# Additional functions {{{

# Output a string with the same quotating style as does bash in set -x
L_set_x_quote() { local tmp; tmp=$({ set -x; : "$@"; } 2>&1); printf "%s\n" "${tmp:5}"; }

# Output a critical message and exit the script.
L_fatal() { L_crit "$*"; exit 2; }

# Eval the first argument - if it returns failure, then fatal.
L_assert() { if eval '!' "$1"; then L_print_traceback2; L_fatal "assertion $1 failed: ${*:2}"; fi }

# Return success if function exists.
L_function_exists() { [[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]; }
L_fn_exists()       { [[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]; }

L_command_exists() { command -v "$@" >/dev/null 2>&1; }
L_cmd_exists() { command -v "$@" >/dev/null 2>&1; }

L_hash() { hash "$@" >/dev/null 2>&1; }
L_am_I_sourced() { [[ "${BASH_SOURCE[0]}" != "${0}" ]]; }

# shellcheck disable=SC2236
L_isset()     { [[ ! -z "${var+x}" ]]; }
# shellcheck disable=SC2236
L_var_isset() { [[ ! -z "${var+x}" ]]; }

L_logrun() {
	L_log "+ ${*@Q}"
	"$@"
}

L_is_false() {
	case "$1" in
	(0+(0)) return 0; ;;
	([fF]) return 0; ;;
	([fF][aA][lL][sS][eE]) return 0; ;;
	esac
	return 1
}

L_is_true() {
	case "$1" in
	(0*(0)) return 1; ;;
	([0-9]*([0-9])) return 0; ;;
	([tT]) return 0; ;;
	([tT][rR][uU][eE]) return 0; ;;
	esac
	return 1
}

: "${L_dryrun:=0}"
L_run_log() {
	local _L_tmp
	_L_tmp="$1" # loglevel
	shift
	if L_is_true "${L_dryrun:-}"; then
		L_logl "$_L_tmp" "DRYRUN: + ${*@Q}"
	else
		L_logl "$_L_tmp" "+ ${*@Q}"
		"$@"
	fi
}
L_run() {
	L_run_log L_LOG_INFO "$@"
}

L_list_functions_with_prefix() {
	compgen -A function | LC_ALL=C sed -n "s/^$*//p" | LC_ALL=C sort
}

###############################################################################

# https://unix.stackexchange.com/questions/39623/trap-err-and-echoing-the-error-line
## Outputs Front-Mater formatted failures for functions not returning 0
## Use the following line after sourcing this file to set failure trap
##    trap 'failure "LINENO" "BASH_LINENO" "${BASH_COMMAND}" "${?}"' ERR
L_trap_err_failure() {
    local -n _lineno="LINENO"
    local -n _bash_lineno="BASH_LINENO"
    local _last_command="${2:-$BASH_COMMAND}"
    local _code="${1:-0}"

    ## Workaround for read EOF combo tripping traps
    if ! ((_code)); then
        return "${_code}"
    fi

    local _last_command_height
	_last_command_height="$(wc -l <<<"${_last_command}")"

    local -a _output_array=()
    _output_array+=(
        '---'
        "lines_history: [${_lineno} ${_bash_lineno[*]}]"
        "function_trace: [${FUNCNAME[*]}]"
        "exit_code: ${_code}"
    )

    if [[ "${#BASH_SOURCE[@]}" -gt '1' ]]; then
        _output_array+=('source_trace:')
        for _item in "${BASH_SOURCE[@]}"; do
            _output_array+=("  - ${_item}")
        done
    else
        _output_array+=("source_trace: [${BASH_SOURCE[*]}]")
    fi

    if [[ "${_last_command_height}" -gt '1' ]]; then
        _output_array+=(
            'last_command: ->'
            "${_last_command}"
        )
    else
        _output_array+=("last_command: ${_last_command}")
    fi

    _output_array+=('---')
    printf '%s\n' "${_output_array[@]}" >&2
    exit "$_code"
}

L_print_traceback2() {
	echo "Traceback from pid $BASHPID (most recent call last):"
	local i s l f tmp offset
	offset=${1:-0}
	for ((i = ${#BASH_SOURCE[@]} - 1; i > offset; --i)); do
		s=${BASH_SOURCE[i]}
		l=${BASH_LINENO[i - 1]}
		f=${FUNCNAME[i]}
		echo "  File $(printf "%q" "$s"), line $l, in $f"
		if tmp=$(awk -v "L=$l" -v M=2 'NR>L-M && NR<L+M { printf "%-5d%3s%s\n",NR,(NR==L?">> ":""),$0 }' "$s" 2>/dev/null) &&
				[[ -n "$tmp" ]]; then
			echo "$tmp"
		fi
	done
	L_crit "Command returned with non-zero exit status: ${1:-0}"
}

L_trap_err_show_source() {
	local idx=${1:-0}
    echo "Traceback:"
    awk -v L="${BASH_LINENO[idx]}" -v M=3 'NR>L-M && NR<L+M { printf "%-5d%3s%s\n",NR,(NR==L?">> ":""),$0 }' "${BASH_SOURCE[idx+1]}"
	L_crit "command returned with non-zero exit status"
}

L_trap_err_small() {
	L_error "fatal error on $(caller)"
}

if ! L_fn_exists L_trap_err; then
L_trap_err() {
    local _code="${1:-0}"
    ## Workaround for read EOF combo tripping traps
    if ! ((_code)); then
        return "${_code}"
    fi
	{
		#L_trap_err_show_source 1 "$@"
		L_print_traceback2 1 "$@"
	} >&2 ||:
    exit "$_code"
}
fi

if [[ "$-" =~ e ]]; then
	set -E -o functrace
	trap 'L_trap_err "$?" "$BASH_COMMAND" -- "${BASH_SOURCE[@]}" -- "${BASH_LINENO[@]}" -- "${FUNCNAME[@]}"' ERR
fi

###############################################################################

L_kill_all_jobs() {
	local IFS=$'\n'
	for j in $(jobs | awk '{gsub("[^0-9]","",$1);print $1}'); do kill "%$j"; done
}

_L_lib_drop_L_prefix() {
	for i in run fatal logl log emerg alert crit err warning notice info debug panic error warn; do
		eval "$i() { L_$i \"\$@\"; }"
	done
}

L_sed_show_diff() {
	(
		file="${*: -1}"
		tmpf=$(mktemp)
		trap 'rm -f "$tmpf"' EXIT
		sed "$@" > "$tmpf"
		diff "$file" "$tmpf" ||:
		if [[ "${L_LIB_LIB_SED_INPLACE:-}" = 'true' ]]; then
			mv "$tmpf" "$file"
		fi
	)
}

L_sed_inplace_show_diff() {
	(
		L_LIB_LIB_SED_INPLACE=true
		L_sed_show_diff "$@"
	)
}

L_is_valid_variable_name() {
	[[ "$1" =~ ^[a-z][a-zA-Z0-9_]*$ ]]
}

L_str_is_print() {
	grep -Fq '[[:print:]]' <<<"$*"
}

# }}}
# L_unittest {{{

_L_unittest_internal() {
	local _L_tmp
	_L_tmp=0
	"${@:3}" || _L_tmp=$?
	((_L_unittest_result|=0)) ||:
	if ((_L_tmp)); then
		echo -n "${L_RED}${L_BRIGHT}"
	fi
	echo -n "${FUNCNAME[2]}:${BASH_LINENO[1]}${1:+: }${1:-}: "
	if ((_L_tmp == 0)); then
		echo "${L_GREEN}OK${L_RESET}"
	else
		((_L_unittest_result|=1)) ||:
		_L_tmp=("${@:3}")
		echo "expr ${_L_tmp[*]@Q} FAILED!${2:+ }${2:-}${L_RESET}"
		return 1
	fi
} >&2

L_unittest_assert() {
	_L_unittest_internal "test eval ${1@Q}" "${*:2}" eval "$1" ||:
}

L_unittest_checkexit() {
	local _L_ret
	_L_ret=0
	eval "${@:2}" || _L_ret=$?
	_L_unittest_internal "test exit of ${*:2} is $1" "$_L_ret != $1" [ "$_L_ret" -eq "$1" ] ||:
}

L_unittest_pipes() {
	if [[ "$1" = "!" ]]; then
		shift
		set -- "${3:-}" "${*:4}" ! cmp -s "$1" "$2"
	else
		set -- "${3:-}" "${*:4}" diff -Naur "$1" "$2"
	fi
	_L_unittest_internal "test pipes${1:+: }$1" "$2" "${@:3}" ||:
}

L_unittest_vareq() {
	if ! _L_unittest_internal "test: \$$1=${!1} == $2" "" [ "${!1}" == "$2" ]; then
		if L_str_is_print "${!1}" "$2"; then
			diff -Naur <(cat <<<"${!1}") - <<<"$2"
		else
			diff -Naur <(xxd -p <<<"${!1}") <(xxd -p <<<"$2")
		fi
	fi
}

# }}}
# trapchain library{{{

# printf "%q" "$(seq 255 | xargs printf "%02x\n" | xxd -r -p)"
_L_allchars=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377'

L_get_trap_number_from_name() {
	trap -l | sed -n 's/.*[^0-9]\([0-9]\+\)) SIGUSR1.*/\1/p'
}

L_get_trap_name() {
	local tmp
	(
		trap ': 0738dc3c-6716-44a1-960a-991b0ec4abaa' "$1"
		trap -p | awk '/0738dc3c-6716-44a1-960a-991b0ec4abaa/{print $NF}'
	)
}

L_extract_trap() {
	local tmp
	tmp=$(L_get_trap_name "$@")
	trap -p "$tmp" |
		sed '1s/^trap -- //; $s/ [^ ]\+$//' |
		sed "1s/^'//; s/'\\\\''/'/g; \$s/'$//"
}

# shellcheck disable=2064
_L_trapchain_unittest() {
	(
		trap "$_L_allchars" "$(L_get_trap_number_from_name SIGUSR1)"
		tmp=$(L_extract_trap SIGUSR1)
		L_unittest_vareq tmp "$_L_allchars"
	)
}

_L_trapchain_callback() {
	# This is what it takes.
	local _L_tmp
	_L_tmp=_L_trapchain_data_$1
	eval "${!_L_tmp}"
}

# shellcheck disable=2064
L_trapchain() {
	local name
	name=$(L_get_trap_name "$2") &&
	trap "_L_trapchain_callback $name" "$name" &&
	eval "_L_trapchain_data_$2=\"\$1\"\$'\\n'\"\$_L_trapchain_data_$2\""
}

# shellcheck disable=2016
_L_trapchain_test() {
	local tmp
	local allchars
	tmp=$(
		L_trapchain 'echo -n "!"' EXIT
		L_trapchain 'echo -n world' EXIT
		L_trapchain 'echo -n " "' EXIT
		L_trapchain 'echo -n hello' EXIT
	)
	L_unittest_assert '[[ "$tmp" == "hello world!" ]]' "tmp=$tmp"
	allchars="$_L_allchars"
	tmp=$(
		printf -v tmp %q "$allchars"
		L_trapchain 'echo -n "hello"' SIGUSR1
		L_trapchain "echo $tmp" SIGUSR1
		L_trapchain 'echo -n world' SIGUSR2
		L_trapchain 'echo -n " "' SIGUSR2
		L_trapchain 'echo -n "!"' EXIT
		L_raise SIGUSR1
		L_raise SIGUSR2
	)
	local res
	res="$allchars"$'\n'"hello world!"
	L_unittest_assert '[[ "$tmp" == "$res" ]]' $'\n'"tmp=${tmp@Q}"$'\n'"res=${res@Q}"
}

L_raise() {
	kill -s "$1" "$BASHPID"
}

# }}}
# Map {{{

_L_map_test() {
	local var tmp
	var=123
	tmp=123
	L_map_init var
	L_map_set var a 1
	L_unittest_pipes <(L_map_get var a) <(echo -n 1)
	L_unittest_pipes <(L_map_get var b) <(:)
	L_map_set var b 2
	L_unittest_pipes <(L_map_get var a) <(echo -n 1)
	L_unittest_pipes <(L_map_get var b) <(echo -n 2)
	L_map_set var a 3
	L_unittest_pipes <(L_map_get var a) <(echo -n 3)
	L_unittest_pipes <(L_map_get var b) <(echo -n 2)
	L_unittest_checkexit 1 L_map_get var c
	L_unittest_checkexit 1 L_map_has var c
	L_unittest_checkexit 0 L_map_has var a
	L_map_set var allchars "$_L_allchars"
	L_unittest_pipes <(L_map_get var allchars) <(printf %s "$_L_allchars") "L_map_get var d"
	L_map_clear var allchars
	L_unittest_checkexit 1 L_map_get var allchars
}

_L_map_check() {
	for i in "$1" "$2"; do
		if ! L_is_valid_variable_name "$i"; then
			L_error "L_map: is not valid variable name: $i";
			return 1
		fi
	done
}

# L_map consist of an empty initial newline.
# Then follows map name, follows a spce, and then printf %q of the value.
#
#                     # empty initial newline
#     key $'value'
#     key2 $'value2'
#
# This format matches the regexes used in L_map_get for easy extraction using bash
# Variable substituation.
L_map_init() {
	printf -v "$1" "\n"
}

L_map_clear() {
	if ! _L_map_check "$@"; then return 2; fi
	local _L_map_name
	_L_map_name=${!1}
	_L_map_name="${_L_map_name/$'\n'"$2 "+([!$'\n'])/}"
	printf -v "$1" %s "$_L_map_name"
}

L_map_set() {
	L_map_clear "$1" "$2"
	local _L_map_name
	_L_map_name=${!1}
	# This code strongly bases that `printf %q` _never_ prints a newline.
	# If it does, I do not have an idea what will happen.
	_L_map_name+=$'\n'"$2 $(printf %q "${*:3}")"
	printf -v "$1" %s "$_L_map_name"
}

L_map_append() {
	local _L_map_name
	if _L_map_name=$(L_map_get "$1" "$2");then
		L_map_set "$1" "$2" "$_L_map_name${4:-}$3"
	else
		L_map_set "$1" "$2" "$3"
	fi
}

L_map_get() {
	if ! _L_map_check "$@"; then return 2; fi
	local _L_map_name
	_L_map_name=${!1}
	local var
	var="$_L_map_name"
	var=${var##*$'\n'"$2 "}
	if [[ "$var" == "$_L_map_name" ]]; then
		return 1
	fi
	var=${var%%$'\n'*}
	eval "printf %s $var"
}

L_map_has() {
	if ! _L_map_check "$@"; then return 2; fi
	local _L_map_name
	_L_map_name=${!1}
	[[ "$_L_map_name" =~ $'\n'"$2 " ]]
}

L_map_getnl() {
	L_map_get "$@"
	echo
}

# }}}
# Argument parser {{{

# shellcheck disable=2016,2154
_L_argparse_test() {
	local arg="" num numbers
	local args
	args=$(L_argparse \
		description="description" epilog="epilog" -- \
		-n --num dest=num -- \
		numbers nargs="+" -- \
		-- -n $'\303(' 2 3
	)
	L_unittest_checkexit 0 "(($? == 2))"
	eval "$args"
	L_unittest_pipes <(echo "$num") <(echo $'\303(')
	L_unittest_pipes <(printf "%s\n" "${numbers[@]}") <(printf "%s\n" 2 3)

	local allchars args allcharsnoslash
	allchars=$(seq 255 | xargs -d'\n' printf "%02x" | xxd -r -p)
	args=$(L_argparse -- \
		arg -- \
		-- "$allchars"
	)
	L_unittest_checkexit 0 "(($? == 2))"
	eval "$args"
	L_unittest_pipes <(printf "%s" "$arg") <(printf "%s" "$allchars")

	allchars=$(seq 255 | xargs -d'\n' printf "%02x" | xxd -r -p)
	allcharsnoslash=$(tr -d '/' <<<"$allchars")

	args=$(L_argparse -- \
		arg nargs='+' -- \
		-- "$allchars" "$allchars" "'"
	)
	L_unittest_checkexit 0 "(($? == 2))"
	eval "$args"
	L_unittest_pipes <(printf "%s\0" "${arg[@]}") <(printf "%s\0" "$allchars" "$allchars" "'")

	L_unittest_checkexit 0 'L_argparse description=bb7895c0-1644-49a8-8499-472beec5b075 -- -- -h | grep -q bb7895c0-1644-49a8-8499-472beec5b075'
	L_unittest_checkexit 1 L_argparse 2>/dev/null
	L_unittest_checkexit 1 L_argparse -- 2>/dev/null
	L_unittest_checkexit 0 L_argparse -- -- -h >/dev/null
	L_unittest_checkexit 0 'L_argparse -- --; (($? == 2))'

	L_argparse_errexit -- \
		-n --num -- \
		numbers nargs='+' -- \
		-- -n 123 2 3
	L_unittest_checkexit 0 '((num == 123))'
	L_unittest_checkexit 0 '((${numbers[0]} == 2))'
	L_unittest_checkexit 0 '((${numbers[1]} == 3))'

	L_unittest_checkexit 2 L_argparse -- \
		-q dest=_L_lib_loadonly action=store_true -- \
		-- -q '>/dev/null'

	(
		tmpd=$(mktemp -d)
		trap 'rm -r "$tmpd"' EXIT
		f="$tmpd/$allcharsnoslash"
		touch -- "$f"
		L_argparse_errexit "PREFIX_" -- \
			-f --file type=file_w -- \
			-g --gfile type=file_w -- \
			-- -f "$f" -g /dev/stdout
		L_unittest_pipes <(echo "$PREFIX_gfile") <(echo /dev/stdout)
		L_unittest_pipes <(cat <<<"$PREFIX_file") <(cat <<<"$f")
	)

	L_argparse_errexit "PREFIX_" -- \
			-n type=int -- \
			-- -n 123
	L_argparse_errexit "PREFIX_" -- \
			-d type=path -- \
			-- -d /dev/

	L_argparse_errexit PREFIX_ prog=myname description="This is just an example how to use this program." \
				epilog="Written by Kamil Cukrowski and this example is free to use." -- \
			-n dest=number type=int help="Give me a number" -- \
			-f --file type=file_r help="This is a file" -- \
			-o --ofile type=file_w help="This is output file" -- \
			-g --ogile type=file_rw help="You can guess it" -- \
			-p --database type=path help="This is a path to database" -- \
			args nargs='+' help="Additional positional arguments" -- \
			-- -n 123 -f /dev/stdout -p /var/log/ some arguments
	eval "$args"
	L_unittest_vareq PREFIX_number 123
	L_unittest_vareq PREFIX_file  /dev/stdout
	L_unittest_vareq PREFIX_database /var/log
	L_unittest_vareq PREFIX_args[0] some
	L_unittest_vareq PREFIX_args[1] arguments
	L_unittest_checkexit 1 'L_isset PREFIX_ofile'
	L_unittest_checkexit 1 'L_isset PREFIX_gfile'
}

L_argparse() {
	LC_ALL=C python - "$L_NAME" "$@" <<'EOF'
from __future__ import print_function
import argparse
import sys
import os
import io
import pathlib

# https://stackoverflow.com/questions/37572837/how-can-i-make-python-3s-print-fit-the-size-of-the-command-prompt
def get_terminal_columns():
	if sys.version_info.major == 3:
		import shutil
		return shutil.get_terminal_size().columns
	else:
		return 79
def eprint_autobreak(*args):
	import textwrap
	width = get_terminal_columns()  # Check size once to avoid rechecks per "paragraph"
	# Convert all args to strings, join with separator, then split on any newlines,
	# preserving line endings, so each "paragraph" wrapped separately
	for line in "".join(map(str, args)).splitlines(True):
		# Py3's print function makes it easy to print textwrap.wrap's result as one-liner
		eprint(*textwrap.wrap(line, width), sep="\n")

def eprint(*args, **kwargs):
	print(*args, file=sys.stderr, **kwargs)

def strchr(str, c):
	return str.find(c) == -1

fsencode = os.fsencode if sys.version_info.major == 3 else str
filetype = io.IOBase if sys.version_info.major == 3 else file

myusage = "Usage: L_argparse [variable_prefix] [argparse.ArgumentParser(arguments)...] -- [argparse.add_argument(arguments)... --]... -- <script_arguments>"
def errusage(*args):
	eprint_autobreak(
		myusage, "\n",
		"See L_argparse --help for more information.", "\n"
		"error: ", *args
	)
	sys.exit(1)

def usage():
	eprint_autobreak(myusage)
	eprint_autobreak("""
A special wrapper around python argparse to parse and export data to shell.
The arguments given to the script are split on '=' character and passe as a dictionary to argparse.ArgumentParser and
argparse.add_arguments functions. The first part before first -- is passed to ArgumetnParser, following parts are passed
to add_argument.

Example usage could look like the following:""")
	eprint("""
	set -- -n 123 -f /dev/stdout -p /var/log/ some arguments
	args=$(L_argparse PREFIX_ prog=myname description="This is just an example how to use this program." \\
				epilog="Written by Kamil Cukrowski and this example is free to use." -- \\
			-n dest=number type=int help="Give me a number" -- \\
			-f --file type=file_r help="This is read file" -- \\
			-o --ofile type=file_w help="This is output file" -- \\
			-g --ogile type=file_rw help="You can guess it" -- \\
			-p --database type=path help="This is a path to database" -- \\
			args nargs='+' help="Additional positional arguments" -- \\
			-- "$@"
	)
	ret=$?
	if ((ret == 0)); then
		echo "Help was displayed";
		exit
	elif ((ret == 1)); then
		echo "There was a parsing error";
		exit 1
	elif ((ret != 2)); then
		echo "There is an unhandled error that happened";
		exit 1
	fi
	# ret == 2
	eval "$args"
	echo "PREFIX_number=$PREFIX_number"
	echo "PREFIX_file=$PREFIX_file"
	echo "PREFIX_database=$PREFIX_database"
	echo "PREFIX_args=(${PREFIX_args[*]})"
	""")
	eprint_autobreak("Written by Kamil Cukrowski. Licensed jointly under MIT License and Beerware License.")
	sys.exit(0)

# Handle --help separately
if len(sys.argv) == 3 and sys.argv[2] in ("-h","--help"):
	usage()

class ArgparseBuilder:
	type_dict={
		"file_w": argparse.FileType('w'),
		"file_r":  argparse.FileType('r'),
		"file": argparse.FileType('rw') ,
		"file_": argparse.FileType('rw') ,
		"file_rw": argparse.FileType('rw'),
		"int": int,
		"float": float,
		# "ascii": ascii,
		"ord": ord,
		"open": open,
		"path": pathlib.Path,
		"pathlib.Path": pathlib.Path,
	}
	def convert_special(self, k, v):
		if k == "type":
			# Special strings - file_[rw] are handled specially to create argparse.FileType
			if v not in self.type_dict:
				errusage("unhandled type specified: {}={}".format(k, v))
			return self.type_dict[v]
		return v

	def __init__(self, argv):
		self.args = argv

	def is_our_option_separator(self, s):
		return s == "-" or s == "--"

	def build(self):
		# Our looping arguments state.
		a_args = []; a_kwargs = dict()
		# The first argument is the program name - it goes to argparse.ArgumentParser first argument.
		a_kwargs["prog"] = self.args.pop(0)
		# The second argument is expected to be prefix for variables.
		if not self.args:
			errusage("not enough arguments")
		# The first argument, if it's not --, is the variable prefix.
		a_prefix = b""
		if self.args and not self.is_our_option_separator(self.args[0]) and strchr(self.args[0], "="):
			a_prefix = fsencode(self.args.pop(0))
			if not self.args:
				errusage("not enough arguments")
		# From a list of arguments separated by == extract sublists
		# from sublists extract arguments with `=` and `-` assign twose to a dictionati in kwargs
		# other asing to array args
		# and then pass the first sublist to argparse.ArgumentParser
		# and other to argparse.add_argument
		# Such build the parsing. Parsing ends on empty list, ie. `-- --`.
		a_first = True
		for i in range(len(self.args)):
			arg = self.args[i]
			if not self.is_our_option_separator(arg):
				if strchr(arg, "=") or arg[0] == "-":
					a_args += [arg]
				else:
					(k, v) = arg.split('=', 1)
					a_kwargs[k] = self.convert_special(k, v)
			else:
				# eprint(a_first, a_args, a_kwargs)
				if a_first:
					a_first = False
					parser = argparse.ArgumentParser(*a_args, **a_kwargs)
				else:
					parser.add_argument(*a_args, **a_kwargs)
				a_args = []; a_kwargs = dict()
				if i + 1 >= len(self.args):
					errusage("double -- -- is missing in arguments")
				if self.is_our_option_separator(self.args[i + 1]):
					break
		if not self.is_our_option_separator(self.args[i]) and not self.is_our_option_separator(self.args[i + 1]):
			errusage("double -- -- is missing in arguments")
		# The rest of arguments are the arguments actually to be parsed
		self.args = self.args[i + 2:]
		return (a_prefix, parser.parse_args(self.args))


class ArgsOutputter:
	outbuf = b""

	def shellquote(self, s):
		if sys.version_info.major == 3:
			return b"'" + s.replace(b"'", b"'\\''") + b"'"
		else:
			return b"'" + str.replace(s, b"'", b"'\\''") + b"'"

	def write(self, *args):
		for i in args:
			self.outbuf += i

	def flush(self):
		if sys.version_info.major == 3:
			sys.stdout.buffer.write(self.outbuf)
		else:
			sys.stdout.write(self.outbuf)

	# Convert specific python type to a byte array for bash importing.
	conv_matrix = {
		bool: lambda val: b"true" if val else b"false",
		str: lambda val: fsencode(val),
		(int, float): lambda val: str(val).encode(),
		filetype: lambda val: fsencode(val.name),
		pathlib.Path: lambda val: fsencode(val.absolute()),
	}

	# Output "variable=value".
	def varprint(self, var, val):
		self.write(var.encode())
		self.write(b"=")
		str = b""
		for (t, l) in self.conv_matrix.items():
			if isinstance(val, t):
				str = self.shellquote(l(val))
				break
		if not str:
			errusage("Unhandled type= specified for {} option ".format(val), type(val))
		self.write(str)

	def parse(self, prefix, args):
		# For each argument parsed now in args, convert it and output
		# into a form eval-able in bash.
		for k in args.__dict__:
			v = args.__dict__[k]
			if v is not None:
				if isinstance(v, list):
					# Create a bash array from list
					self.write(prefix)
					self.write(k.encode())
					self.write(b"=(")
					for i in range(len(v)):
						self.varprint("[{}]".format(i), v[i])
						if i + 1 != len(v):
							self.write(b" ")
					self.write(b")\n")
				else:
					self.write(prefix)
					self.varprint(k, v)
					self.write(b"\n")
		return self

# The first argument is '-', so we start from second one.
(prefix, args) = ArgparseBuilder(sys.argv[1:]).build()
ArgsOutputter().parse(prefix, args).flush()
sys.exit(2)

EOF
}

L_argparse_errexit() {
	local args
	args=$(L_argparse "$@")
	if (($? != 2)); then
		exit "$?"
	fi
	eval "$args"
}

# }}}
# lib_lib functions {{{

_L_lib_name=${BASH_SOURCE##*/}

_L_lib_lib_error() {
	echo "$_L_lib_name: ERROR: $*" >&2
}

_L_lib_lib_fatal() {
	_L_lib_lib_error "$@"
	exit 3
}

_L_lib_lib_list_prefix_functions() {
	L_list_functions_with_prefix "$L_prefix"
}

if ! L_fn_exists L_cb_usage_usage; then L_cb_usage_usage() {
	echo "Usage:  $L_name <COMMAND> [OPTIONS]"
}; fi

if ! L_fn_exists L_cb_usage_desc; then L_cb_usage_desc() {
	:;
}; fi

if ! L_fn_exists L_cb_usage_footer; then L_cb_usage_footer() {
	echo 'Written by Kamil Cukrowski. Licensed jointly under MIT License and Beeware License'
}; fi

# shellcheck disable=2046
_L_lib_lib_their_usage() {
	if L_function_exists L_cb_usage; then
		L_cb_usage $(_L_lib_lib_list_prefix_functions)
		return
	fi
	local a_usage a_desc a_cmds a_footer
	a_usage=$(L_cb_usage_usage)
	a_desc=$(L_cb_usage_desc)
	a_cmds=$(
		{
			for f in $(_L_lib_lib_list_prefix_functions); do
				desc=""
				if L_function_exists L_cb_"$L_prefix$f"; then
					L_cb_"$L_prefix$f" "$f" "$L_prefix"
				fi
				echo "$f${desc:+$'\01'}$desc"
			done
			echo "-h --help"$'\01'"print this help and exit"
			echo "--bash-completion"$'\01'"generate bash completion to be eval'ed"
		} | {
			if L_cmd_exists column && column -V 2>/dev/null | grep -q util-linux; then
				column -t -s $'\01' -o '   '
			else
				sed 's/#/    /'
			fi
		} | sed 's/^/  /'
	)
	a_footer=$(L_cb_usage_footer)
	cat <<EOF
${a_usage}

${a_desc:-}${a_desc:+

}Commands:
$a_cmds${a_footer:+

}${a_footer:-}
EOF
}

_L_lib_lib_show_best_match() {
	if tmp=$(
		_L_lib_lib_list_prefix_functions |
		if L_hash fzf; then
			fzf -0 -1 -f "$1"
		else
			grep -F "$1"
		fi
	) && [[ -n "$tmp" ]]; then
		echo
		echo "The most similar commands are"
		# shellcheck disable=2001
		<<<"$tmp" sed 's/^/\t/'
	fi >&2
}

# https://stackoverflow.com/questions/14513571/how-to-enable-default-file-completion-in-bash
# shellcheck disable=2207
_L_do_bash_completion() {
	if [[ "$(LC_ALL=C type -t -- "_L_cb_bash_completion_$L_NAME" 2>/dev/null)" = function ]]; then
		"_L_cb_bash_completion_$L_NAME" "$@"
		return
	fi
    if ((COMP_CWORD == 1)); then
        COMPREPLY=($(compgen -W "${cmds[*]}" -- "${COMP_WORDS[1]}"))
		# add trailing space to each
        #COMPREPLY=("${COMPREPLY[@]/%/ }")
    else
		COMPREPLY=()
    fi
}

# shellcheck disable=2120
_L_lib_lib_bash_completion() {
	local tmp cmds
	tmp=$(_L_lib_lib_list_prefix_functions)
	mapfile -t cmds <<<"$tmp"
	local funcname
	funcname=_L_bash_completion_$L_NAME
	eval "$funcname() {
		$(declare -p cmds L_NAME)"'
		_L_do_bash_completion "$@"
	}'
	declare -f _L_do_bash_completion "$funcname"
	printf "%s" "complete -o bashdefault -o default -F"
	printf " %q" "$funcname" "$0" "$L_NAME"
	printf '\n'
}

_L_lib_lib_usage() {
	cat <<EOF
Usage:
      . $_L_lib_name [options] -q
      . $_L_lib_name [options] <prefix> "\$@"
	  $_L_lib_name --test

A library to be called from other libraries. This is a simple script to
allow me to write simple reusable programs with bash completion and much
more TODO!

Usage example:

	# script.sh
	LIB_prefix_some_func() {
		desc="this func does that"
	}
    prefix_some_func() {
		echo 'yay!'
	}
    prefix_some_other_func() {
		echo 'not yay!'
	}
	source $_L_lib_name 'prefix_' "\$@"

Then you can enter from command line:

	script.sh some_func

You can import bash completion for the script with:

	eval "\$(script.sh --bash-completion)"

Options:
	-L   Drop L_ prefix on some functions
	-q   Only import library - do not parse arguments
	-l   Both -L and -q

Written by Kamil Cukrowski 2020.
Licensed jointly under Beerware License and MIT License.
EOF
}

# }}}
# Library end {{{
fi
# }}}
# lib_lib main {{{

# Easier to use library - drop L_ prefix on some functions if -L argument is passed
_L_lib_lib_args=$(getopt -n "$L_NAME:$_L_lib_name" -o +Llqh -l help,test:: -- "$@")
eval "set -- $_L_lib_lib_args"
_L_lib_loadonly=0
_L_lib_help=0
while (($#)); do
	case "$1" in
	-L) _L_lib_drop_L_prefix; ;;
	-q) _L_lib_loadonly=1; ;;
	-l) _L_lib_drop_L_prefix; _L_lib_loadonly=1; ;;
	-h|--help) _L_lib_help=1; ;;
	--test) break; ;;
	--) shift; break; ;;
	*) L_fatal "$_L_lib_name: Internal error when parsing arguments"; ;;
	esac
	shift
done

if ! L_am_I_sourced; then
	if (($# >= 2)) && [[ "$1" == "--test" ]]; then
		L_assert "(($# <= 3))" "too many arguments for --test"
		tests=$(
			compgen -A function |
			grep -x '_L_.*_test' |
			if [[ -n "${2:-}" ]]; then grep "$2"; else cat; fi ||:
		)
		for i in $tests; do
			"$i"
		done
		exit "${_L_unittest_result:-5}"
	fi
	_L_lib_lib_usage
	if ((_L_lib_help)); then exit 0; fi
	_L_lib_lib_fatal "Script $_L_lib_name has to be sourced!"
	exit 1
fi

if ((_L_lib_loadonly)); then
	if (($#)); then L_warning "Do not pass arguments with -q option"; fi
	unset _L_lib_loadonly _L_lib_lib_args
	return
fi
unset _L_lib_loadonly _L_lib_lib_args

if (($# == 0)); then _L_lib_lib_fatal "prefix argument missing"; fi
L_prefix=$1
case "$L_prefix" in
(-*) _L_lib_lib_fatal "prefix argument cannot start with -"; ;;
("") _L_lib_lib_fatal "prefix argument is empty"; ;;
esac
shift

case "${1:-}" in
(--bash-completion)
	_L_lib_lib_bash_completion
	return
	exit
	;;
(-h|--help)
	_L_lib_lib_their_usage "$@"
	return
	exit
	;;
esac
if L_fn_exists "L_cb_parse_args"; then
	unset L_cb_args
	L_cb_parse_args "$@"
	if ! L_var_isset L_cb_args; then L_error "L_cb_parse_args did not return L_cb_args array"; fi
	# shellcheck disable=2154
	set -- "${L_cb_args[@]}"
fi

if (($# == 0)); then
	if ! L_fn_exists "${L_prefix}DEFAULT"; then
		_L_lib_lib_their_usage "$@"
		L_error "Command argument missing."
		exit 1
	fi
fi
L_mode="${1:-DEFAULT}"
shift
if ! L_function_exists "$L_prefix$L_mode"; then
	L_error "Unknown command: '$L_mode'. See '$L_NAME --help'."
	_L_lib_lib_show_best_match "$L_mode"
	exit 1
fi
"$L_prefix$L_mode" "$@"

# }}}

# vim: foldmethod=marker

