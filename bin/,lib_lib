#!/bin/bash
# This is a collection of libraries that I seem to use over and over
# again and again inm every script I write.
# It's here to simplify my use of it.
# Written by Kamil Cukrowski
# Licensed jointly under MIT License and Beerware License
# SPDX-License-Identifier: MIT + Beerware

# Library start {{{

# Source only once, to speed up
if [[ -z "${L_LIB_LIB_SOURCED:-}" ]]; then
L_LIB_LIB_SOURCED=true
readonly L_LIB_LIB_SOURCED

# }}}
# Globals {{{

L_name=${0##*/}
L_dir=${0%/*}
L_NAME="$L_name"
L_DIR="$L_dir"
readonly L_NAME L_DIR

# }}}
# Colors {{{

L_BOLD=$'\E[1m'
L_BRIGHT=$'\E[1m'
L_DIM=$'\E[2m'
L_FAINT=$'\E[2m'
L_STANDOUT=$'\E[3m'
L_UNDERLINE=$'\E[4m'
L_BLINK=$'\E[5m'
L_REVERSE=$'\E[7m'
L_CONCEAL=$'\E[8m'
L_HIDDEN=$'\E[8m'
L_CROSSEDOUT=$'\E[9m'

L_FONT0=$'\E[10m'
L_FONT1=$'\E[11m'
L_FONT2=$'\E[12m'
L_FONT3=$'\E[13m'
L_FONT4=$'\E[14m'
L_FONT5=$'\E[15m'
L_FONT6=$'\E[16m'
L_FONT7=$'\E[17m'
L_FONT8=$'\E[18m'
L_FONT9=$'\E[19m'

L_FRAKTUR=$'\E[20m'
L_DOUBLE_UNDERLINE=$'\E[21m'
L_NODIM=$'\E[22m'
L_NOSTANDOUT=$'\E[23m'
L_NOUNDERLINE=$'\E[24m'
L_NOBLINK=$'\E[25m'
L_NOREVERSE=$'\E[27m'
L_NOHIDDEN=$'\E[28m'
L_REVEAL=$'\E[28m'
L_NOCROSSEDOUT=$'\E[29m'

L_BLACK=$'\E[30m'
L_RED=$'\E[31m'
L_GREEN=$'\E[32m'
L_YELLOW=$'\E[33m'
L_BLUE=$'\E[34m'
L_MAGENTA=$'\E[35m'
L_CYAN=$'\E[36m'
L_LIGHT_GRAY=$'\E[37m'
L_DEFAULT=$'\E[39m'
L_FOREGROUND_DEFAULT=$'\E[39m'

L_BACKGROUND_BLUE=$'\E[44m'
L_BACKGROUND_CYAN=$'\E[46m'
L_BACKGROUND_DEFAULT=$'\E[49m'
L_BACKGROUND_GREEN=$'\E[42m'
L_BACKGROUND_LIGHT_GRAY=$'\E[47m'
L_BACKGROUND_MAGENTA=$'\E[45m'
L_BACKGROUND_YELLOW=$'\E[43m'
L_B_BLACK=$'\E[40m'
L_B_BLUE=$'\E[44m'
L_B_CYAN=$'\E[46m'
L_B_GREEN=$'\E[42m'
L_B_LIGHT_GRAY=$'\E[47m'
L_B_MAGENTA=$'\E[45m'
L_B_RED=$'\E[41m'
L_B_YELLOW=$'\E[43m'

L_FRAMED=$'\E[51m'
L_ENCIRCLED=$'\E[52m'
L_OVERLINED=$'\E[53m'
L_NOENCIRCLED=$'\E[54m'
L_NOFRAMED=$'\E[54m'
L_NOOVERLINED=$'\E[55m'

L_DARK_GRAY=$'\E[90m'
L_LIGHT_RED=$'\E[91m'
L_LIGHT_GREEN=$'\E[92m'
L_LIGHT_YELLOW=$'\E[93m'
L_LIGHT_BLUE=$'\E[94m'
L_LIGHT_MAGENTA=$'\E[95m'
L_LIGHT_CYAN=$'\E[96m'
L_WHITE=$'\E[97m'

L_BACKGROUND_DARK_GRAY=$'\E[100m'
L_BACKGROUND_LIGHT_BLUE=$'\E[104m'
L_BACKGROUND_LIGHT_CYAN=$'\E[106m'
L_BACKGROUND_LIGHT_GREEN=$'\E[102m'
L_BACKGROUND_LIGHT_MAGENTA=$'\E[105m'
L_BACKGROUND_LIGHT_RED=$'\E[101m'
L_BACKGROUND_LIGHT_YELLOW=$'\E[103m'
L_BACKGROUND_WHITE=$'\E[107m'

L_B_DARK_GRAY=$'\E[100m'
L_B_LIGHT_BLUE=$'\E[104m'
L_B_LIGHT_CYAN=$'\E[106m'
L_B_LIGHT_GREEN=$'\E[102m'
L_B_LIGHT_MAGENTA=$'\E[105m'
L_B_LIGHT_RED=$'\E[101m'
L_B_LIGHT_YELLOW=$'\E[103m'
L_B_WHITE=$'\E[107m'

L_RESET=$'\E(B\E[m'

L_ansi_up() { printf $'\E[%dA' "$@"; }
L_ansi_down() { printf $'\E[%dB' "$@"; }
L_ansi_right() { printf $'\E[%dC' "$@"; }
L_ansi_left() { printf $'\E[%dD' "$@"; }
L_ansi_next_line() { printf $'\E[%dE' "$@"; }
L_ansi_prev_line() { printf $'\E[%dF' "$@"; }
L_ansi_set_column() { printf $'\E[%dG' "$@"; }
L_ansi_set_position() { printf $'\E[%d;%dH' "$@"; }
L_ansi_clear_screen_until_end() { printf '\E[0J'; }
L_ansi_clear_screen_until_beginning() { printf '\E[1J'; }
L_ansi_clear_screen() { printf '\E[2J'; }
L_ansi_clear_line_until_end() { printf '\E[0K'; }
L_ansi_clear_line_until_beginning() { printf '\E[1K'; }
L_ansi_clear_line() { printf '\E[2K'; }
L_ansi_save_position() { printf '\E7'; }
L_ansi_restore_position() { printf '\E8'; }

L_lcolor=
L_lcolor_enable() { L_lcolor=yes; }
L_lcolor_disable() { L_lcolor=; }
if [ -t 1 ]; then
	L_lcolor_enable
fi
# Use: echo "${L_color:+$L_RED}someoutput${L_color:+$L_RESET}"

# }}}
# Loglevel library {{{

L_LOG_EMERG=0	
L_LOG_ALERT=1	
L_LOG_CRIT=2	
L_LOG_ERR=3
L_LOG_WARNING=4	
L_LOG_NOTICE=5	
L_LOG_INFO=6	
L_LOG_DEBUG=7
L_LOG_PRIMASK=7
L_LOG_PRIORITY_NAMES=(
	[L_LOG_EMERG]="emerg"
	[L_LOG_ALERT]="alert"
	[L_LOG_CRIT]="crit"
	[L_LOG_ERR]="err"
	[L_LOG_WARNING]="warning"
	[L_LOG_NOTICE]="notice"
	[L_LOG_INFO]="info"
	[L_LOG_DEBUG]="debug"
)
L_LOG_COLORS=(
	[L_LOG_EMERG]="${L_BOLD}${L_RED}"
	[L_LOG_ALERT]="${L_BOLD}${L_RED}"
	[L_LOG_CRIT]="${L_BOLD}${L_RED}"
	[L_LOG_ERR]="${L_BOLD}${L_RED}"
	[L_LOG_WARNING]="${L_BOLD}${L_YELLOW}"
	[L_LOG_NOTICE]="${L_BOLD}${L_CYAN}"
	[L_LOG_INFO]=""
	[L_LOG_DEBUG]=""
)

L_lmask=0
L_lmask_isallowed() {   (( !(L_lmask & (1 << $1)) )); }
L_lmask_isblocked() {   ((  (L_lmask & (1 << $1)) )); }
L_lmask_allow() {       (( L_lmask &= (1 << $1) ))||:; }
L_lmask_block() {       (( L_lmask |= (1 << $1) ))||:; }
L_lmask_allow_below() { (( L_lmask &= (1 << $1) - 1 ))||:; }
L_lmask_block_below() { (( L_lmask |= (1 << $1) - 1 ))||:; }

L_logname=
L_log_set_backend_printf() {
	L_logl_backend() {
		printf "%s\n" "${L_logname:-$L_name}: ${*:2}" >&2
	}
}
L_log_set_backend_logger() {
	L_logl_backend() {
		logger -s -e -t "${L_logname:-$L_name}" -p "$1" "${*:2}"
	}
}
L_log_set_backend_printf

L_logl() {
	if L_lmask_isallowed "$1"; then
		L_logl_backend "$1" "${L_lcolor:+${L_LOG_COLORS[$1]}}""${L_LOG_PRIORITY_NAMES[$1]:+${L_LOG_PRIORITY_NAMES[$1]}}""${L_lcolor:+${L_RESET}}: ${*:2}"
	fi
}

L_log() {
	if L_lmask_isallowed "$L_LOG_INFO"; then
		L_logl_backend "$L_LOG_INFO" "$@"
	fi
}

L_emerg() { L_logl "$L_LOG_EMERG" "$@"; }
L_alert() { L_logl "$L_LOG_ALERT" "$@"; }
L_crit() { L_logl "$L_LOG_CRIT" "$@"; }
L_err() { L_logl "$L_LOG_ERR" "$@"; }
L_warning() { L_logl "$L_LOG_WARNING" "$@"; }
L_notice() { L_logl "$L_LOG_NOTICE" "$@"; }
L_info() { L_logl "$L_LOG_INFO" "$@"; }
L_debug() { L_logl "$L_LOG_DEBUG" "$@"; }
L_panic() { L_logl "$L_LOG_PANIC" "$@"; }
L_error() { L_logl "$L_LOG_ERR" "$@"; }
L_warn() { L_logl "$L_LOG_WARNING" "$@"; }

# }}}
# Additional functions {{{

# Output a string with the same quotating style as does bash in set -x
L_set_x_quote() { local tmp; tmp=$({ set -x; : "$@"; } 2>&1); printf "%s\n" "${tmp:5}"; }

L_fatal() { L_crit "$*"; exit 2; }
L_function_exists() { [[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]; }
L_fn_exists() { [[ "$(LC_ALL=C type -t -- "$1" 2>/dev/null)" = function ]]; }

L_command_exists() { command -v "$@" >/dev/null 2>&1; }
L_cmd_exists() { command -v "$@" >/dev/null 2>&1; }

L_hash() { hash "$@" >/dev/null 2>&1; }
L_am_I_sourced() { [[ "${BASH_SOURCE[0]}" != "${0}" ]]; }

L_logrun() {
	L_log "+ ${*@Q}"
	"$@"
}

L_dryrun=false
L_run() {
	L_log "+ ${*@Q}"
	if ! "$L_dryrun"; then
		"$@"
	fi
}

L_list_functions_with_prefix() {
	compgen -A function | LC_ALL=C sed -n "s/^$*//p" | LC_ALL=C sort
}

###############################################################################

# https://unix.stackexchange.com/questions/39623/trap-err-and-echoing-the-error-line
## Outputs Front-Mater formatted failures for functions not returning 0
## Use the following line after sourcing this file to set failure trap
##    trap 'failure "LINENO" "BASH_LINENO" "${BASH_COMMAND}" "${?}"' ERR
L_trap_err_failure() {
    local -n _lineno="LINENO"
    local -n _bash_lineno="BASH_LINENO"
    local _last_command="${2:-$BASH_COMMAND}"
    local _code="${1:-0}"

    ## Workaround for read EOF combo tripping traps
    if ! ((_code)); then
        return "${_code}"
    fi

    local _last_command_height
	_last_command_height="$(wc -l <<<"${_last_command}")"

    local -a _output_array=()
    _output_array+=(
        '---'
        "lines_history: [${_lineno} ${_bash_lineno[*]}]"
        "function_trace: [${FUNCNAME[*]}]"
        "exit_code: ${_code}"
    )

    if [[ "${#BASH_SOURCE[@]}" -gt '1' ]]; then
        _output_array+=('source_trace:')
        for _item in "${BASH_SOURCE[@]}"; do
            _output_array+=("  - ${_item}")
        done
    else
        _output_array+=("source_trace: [${BASH_SOURCE[*]}]")
    fi

    if [[ "${_last_command_height}" -gt '1' ]]; then
        _output_array+=(
            'last_command: ->'
            "${_last_command}"
        )
    else
        _output_array+=("last_command: ${_last_command}")
    fi

    _output_array+=('---')
    printf '%s\n' "${_output_array[@]}" >&2
    exit "$_code"
}

L_trap_err_show_source() {
    echo "Traceback:"
    awk -v L="${BASH_LINENO[1]}" -v M=3 'NR>L-M && NR<L+M { printf "%-5d%3s%s\n",NR,(NR==L?">> ":""),$0 }' "${BASH_SOURCE[0]}"
	L_error "command returned with non-zero exit status"
}

L_trap_err_small() {
	L_error "fatal error on $(caller)"
}

if ! L_fn_exists L_trap_err; then
L_trap_err() {
	L_trap_err_show_source "$@"
}
fi

if [[ "$-" =~ e ]]; then
	set -E -o functrace
	trap 'L_trap_err "$?" "$BASH_COMMAND"' ERR
fi

###############################################################################

L_kill_all_jobs() {
	local IFS=$'\n'
	for j in $(jobs | awk '{gsub("[^0-9]","",$1);print $1}'); do kill "%$j"; done
}

_L_lib_drop_L_prefix() {
	for i in run fatal logl log emerg alert crit err warning notice info debug panic error warn; do
		eval "$i() { L_$i \"\$@\"; }"
	done
}

L_sed_show_diff() {
	(
		file="${@: -1}"
		tmpf=$(mktemp)
		trap 'rm -f "$tmpf"' EXIT
		sed "$@" > "$tmpf"
		diff "$file" "$tmpf" ||:
		if [[ "$L_LIB_LIB_SED_INPLACE" = 'true' ]]; then
			mv "$tmpf" "$file"
		fi
	)
}

L_sed_inplace_show_diff() {
	(
		L_LIB_LIB_SED_INPLACE=true
		L_sed_show_diff "$@"
	)
}

L_is_valid_variable_name() {
	[[ "$1" =~ ^[a-z][a-zA-Z0-9_]*$ ]]
}

_L_unittest_check() {
	((_L_unittest_result|=0)) ||:
	echo -n "${FUNCNAME[1]}:${BASH_LINENO[0]}: test "
	if eval "$@"; then
		echo "ok"
	else
		((_L_unittest_result|=1)) ||:
		echo "failed!"
	fi

}

_L_unittest_pipes() {
	((_L_unittest_result|=0)) ||:
	echo -n "${FUNCNAME[1]}:${BASH_LINENO[0]}: test "
	if
		if [[ "$1" = "!" ]]; then
			shift
			! cmp -s "$1" "$2"
		else
			diff -Naur "$1" "$2"
		fi
	then
		echo "ok"
	else
		((_L_unittest_result|=1)) ||:
		echo "failed!"
	fi
}

# }}}
# Map {{{

_L_map_test() {
	local var
	L_map_init var
	L_map_set var a 1
	_L_unittest_pipes <(L_map_get var a) <(echo -n 1)
	_L_unittest_pipes <(L_map_get var b) <(:)
	L_map_set var b 2
	_L_unittest_pipes <(L_map_get var a) <(echo -n 1)
	_L_unittest_pipes <(L_map_get var b) <(echo -n 2)
	L_map_set var a 3
	_L_unittest_pipes <(L_map_get var a) <(echo -n 3)
	_L_unittest_pipes <(L_map_get var b) <(echo -n 2)
	_L_unittest_pipes <(L_map_get var c; echo $?) <(echo 1)
	_L_unittest_pipes <(L_map_has var c; echo $?) <(echo 1)
	_L_unittest_pipes <(L_map_has var a; echo $?) <(echo 0)
}

_L_map_check() {
	if ! L_is_valid_variable_name "$1"; then
		L_error "L_map: is not valid variable name: $1";
		return 1
	fi
}

L_map_init() {
	declare -n _L_map_name="$1"
	_L_map_name=''
}

L_map_clear() {
	if ! _L_map_check "$2"; then return; fi
	declare -n _L_map_name="$1"
	_L_map_name="${_L_map_name/$'\n'"$2 "+([!$'\n'])/}"
}

L_map_set() {
	L_map_clear "$1" "$2"
	declare -n _L_map_name="$1"
	_L_map_name+=$'\n'"$2 $(shift 2; printf "%q" "$*")"
}

L_map_append() {
	local _L_map_name
	if _L_map_name=$(L_map_get "$1" "$2");then
		L_map_set "$1" "$2" "$_L_map_name${4:-}$3"
	else
		L_map_set "$1" "$2" "$3"
	fi
}

L_map_get() {
	if ! _L_map_check "$2"; then return; fi
	local _L_map_name
	_L_map_name=$(declare -n _L_map_name="$1"; printf "%s" "$_L_map_name")
	local var="$_L_map_name"
	var=${var##*$'\n'"$2 "}
	if [[ "$var" == "$_L_map_name" ]]; then
		return 1
	fi
	var=${var%%$'\n'*}
	eval "printf \"%s\" $var"
}

L_map_has() {
	declare -n _L_map_name="$1"
	[[ "$_L_map_name" =~ $'\n'"$2 " ]]
}

L_map_getnl() {
	L_map_get "$@"
	echo
}

# }}}
# Argument parser {{{

_L_argparse_test() {
	local arg="" num numbers
	local args
	args=$(L_argparse \
		description="description" epilog="epilog" -- \
		-n --num dest=num -- \
		numbers nargs="+" -- \
		-- -n $'\303(' 2 3
	)
	_L_unittest_check "(($? == 2))"
	eval "$args"
	_L_unittest_pipes <(echo "$num") <(echo $'\303(')
	_L_unittest_pipes <(printf "%s\n" "${numbers[@]}") <(printf "%s\n" 2 3)

	allchars=$(seq 255 | xargs -d'\n' printf "%02x" | xxd -r -p)
	args=$(L_argparse -- \
		arg -- \
		-- "$allchars"
	)
	_L_unittest_check "(($? == 2))"
	eval "$args"
	_L_unittest_pipes <(printf "%s" "$arg") <(printf "%s" "$allchars")

	allchars=$(seq 255 | xargs -d'\n' printf "%02x" | xxd -r -p)
	args=$(L_argparse -- \
		arg nargs='+' -- \
		-- "$allchars" "$allchars" "'"
	)
	_L_unittest_check "(($? == 2))"
	eval "$args"
	_L_unittest_pipes <(printf "%s\0" "${arg[@]}") <(printf "%s\0" "$allchars" "$allchars" "'")

	_L_unittest_check 'L_argparse description=bb7895c0-1644-49a8-8499-472beec5b075 -- -- -h | grep -q bb7895c0-1644-49a8-8499-472beec5b075'
	_L_unittest_check '!' L_argparse 2>/dev/null
	_L_unittest_check '!' L_argparse -- 2>/dev/null
	_L_unittest_check L_argparse -- -- -h >/dev/null
	_L_unittest_check 'L_argparse -- --; (($? == 2))'

	L_argparse_errexit -- \
		-n --num -- \
		numbers nargs='+' -- \
		-- -n 123 2 3
	_L_unittest_check '((num == 123))'
	_L_unittest_check '((${numbers[0]} == 2))'
	_L_unittest_check '((${numbers[1]} == 3))'
}

L_argparse() {
	python3 - "$L_NAME" "$@" <<'EOF' 
import argparse
import sys
import os

def eprint(*args, **kwargs):
	print(*args, file=sys.stderr, **kwargs)
def shellquote(s):
    return b"'" + s.replace(b"'", b"'\\''") + b"'"
def is_our_option_separator(s):
	return s == "-" or s == "--"

g_inargs = sys.argv[1:]
a_args = []; a_kwargs = dict()
a_args += [ g_inargs.pop(0) ]
if not g_inargs:
	raise Exception("L_argparse: needs arguments")

a_first = True
for i in range(len(g_inargs)):
	arg = g_inargs[i]
	if not is_our_option_separator(arg):
		if arg.find("=") == -1:
			a_args += [arg]
		else:
			(k, v) = arg.split('=', maxsplit=1)
			a_kwargs[k] = v
	else:
		#eprint(a_first, a_args, a_kwargs)
		if a_first:
			a_first = False
			parser = argparse.ArgumentParser(*a_args, **a_kwargs)
		else:
			parser.add_argument(*a_args, **a_kwargs)
		a_args = []; a_kwargs = dict()
		if i + 1 >= len(g_inargs):
			raise Exception("L_argparse: the double -- are missing")
		if is_our_option_separator(g_inargs[i + 1]):
			break

if not is_our_option_separator(g_inargs[i]) and not is_our_option_separator(g_inargs[i + 1]):
	raise Exception("L_argparse: the double -- are missing")
g_inargs = g_inargs[i + 2:]
args = parser.parse_args(g_inargs)

out = sys.stdout.buffer.write
def rprint(s):
	out(s)
def varprint(var, val):
	rprint(var.encode())
	rprint(b"=")
	rprint(shellquote(os.fsencode(val)))

for k in args.__dict__:
	v = args.__dict__[k]
	if v is not None:
		if isinstance(v, list):
			rprint(k.encode())
			rprint(b"=(")
			for i in range(len(v)):
				varprint(f"[{i}]", v[i])
				rprint(b" ")
			rprint(b")\n")
		else:
			varprint(k, v)
			rprint(b"\n")

sys.exit(2)
EOF
}

L_argparse_errexit() {
	local args
	args=$(L_argparse "$@")
	if (($? != 2)); then
		exit "$?"
	fi
	eval "$args"
}

# }}}
# Library end - parse arguments {{{

fi

# Easier to use library - drop L_ prefix on some functions if -L argument is passed
_L_LIB_LIB_args=$(getopt -n "$L_NAME:,lib_lib" -o '+Llq' -l test -- "$@")
eval "set -- $_L_LIB_LIB_args"
_L_LIB_LIB_quiet=0
while (($#)); do
	case "$1" in
	-L) _L_lib_drop_L_prefix; ;;
	-q) _L_LIB_LIB_quiet=1; ;;
	-l) _L_lib_drop_L_prefix; _L_LIB_LIB_quiet=1; ;;
	--test) break; ;;
	--) shift; break; ;;
	*) L_fatal ",lib_lib: Internal error when parsing arguments"; ;;
	esac
	shift
done

# If this file is sourced with only a siungle argument -q then just let
# the upper definitions be visible. This is a library.
if L_am_I_sourced && ((_L_LIB_LIB_quiet)); then
	if (($#)); then L_warning "Do not pass arguments with -q option"; fi
	unset _L_LIB_LIB_quiet _L_LIB_LIB_args
	return
fi
unset _L_LIB_LIB_quiet _L_LIB_LIB_args

# }}}
# ,lib_lib functions {{{

,lib_lib_usage() {
	cat <<'EOF'
Usage:
	# script.sh
	LIB_prefix_some_func() {
		desc="this func does that"
	}		
    prefix_some_func() {
		echo 'yay!'
	}
	source ,lib_lib 'prefix_' "$@"

	# then from command line:
	eval "$(script.sh --bash-autocompletion)"
	script.sh some_func


A library to be called from other libraries
This is a simple script to allow me to write:
- simple reusable programs
- with bash completion
and much more TODO!

Written by Kamil Cukrowski 2020
EOF
}

,lib_lib_error() {
	echo ",lib_lib: ERROR: $*" >&2
}

,lib_lib_fatal() {
	,lib_lib_error "$@"
	exit 3
}

,lib_lib_list_prefix_functions() {
	L_list_functions_with_prefix "$L_prefix"
}

,lib_lib_their_usage() {
	if L_function_exists usage; then
		local tmp saveifs
		tmp=$(,lib_lib_list_prefix_functions)
		saveifs="${IFS:-}"
		IFS=$'\n\r \t' read -r -d '' -a functions <<<"$tmp" ||:
		IFS="$saveifs"
		unset tmp
		usage "${functions[@]}"
		return 
	fi
	cat <<EOF
Usage: $L_name <COMMAND> [OPTIONS]

Commands:
$(
	{
		for f in $(,lib_lib_list_prefix_functions); do
			desc=""
			if L_function_exists LIB_"$L_prefix$f"; then
				LIB_"$L_prefix$f" "$f" "$L_prefix"
			fi
			echo "$f${desc:+#}$desc"
		done
		echo "--bash-completion#Generate bash completion to be eval'ed."
	} |
	if hash column 2>/dev/null >&2; then
		column -t -s '#' -o ' - '
	else
		sed 's/#/ - /'
	fi | sed 's/^/  /'
)

EOF
}

,lib_lib_show_best_match() {
	if
		L_hash fzf &&
		tmp=$(,lib_lib_list_prefix_functions | fzf -0 -1 -f "$1") &&
		[[ -n "$tmp" ]]
	then
		echo "   Maybe you meant: $tmp ?" >&2
	fi
}

# https://stackoverflow.com/questions/14513571/how-to-enable-default-file-completion-in-bash
_lib_lib_do_bash_completion() {
	if [[ "$(LC_ALL=C type -t -- "_lib_lib_do_bash_completion_$L_NAME" 2>/dev/null)" = function ]]; then
		"_lib_lib_do_bash_completion_$L_NAME" "$@"
		return
	fi
    if ((COMP_CWORD == 1)); then
        COMPREPLY=($(compgen -W "${cmds[*]}" -- "${COMP_WORDS[1]}"))
		# add trailing space to each
        #COMPREPLY=("${COMPREPLY[@]/%/ }")
    else
		COMPREPLY=()
    fi
}

,lib_lib_bash_completion() {
	local tmp cmds
	tmp=$(,lib_lib_list_prefix_functions)
	mapfile -t cmds <<<"$tmp"
	local funcname
	funcname=_lib_lib_bash_completion_$L_NAME
	eval "$funcname() {
		local cmds L_NAME
		$(declare -p cmds L_NAME)
		_lib_lib_do_bash_completion "$@"
	}"
	declare -f _lib_lib_do_bash_completion "$funcname"
	printf "%s" complete
	printf " %s" -o bashdefault -o default -F $funcname "$0" "$L_NAME"
	printf "\n"
}

# }}}
# ,lib_lib main {{{

if ! L_am_I_sourced; then
	if (($# == 2)) && [[ "${1:-}" == '--test' ]]; then
		for i in _L_argparse_test _L_map_test; do
			"$i"
		done
		exit "$_L_unittest_result"
	fi
	,lib_lib_usage
	,lib_lib_fatal "Script ,lib_lib has to be sourced!"
fi
if (($# == 0)); then ,lib_lib_fatal "Prefix argument missing"; fi
L_prefix=$1
shift
if [[ -z "$L_prefix" ]]; then ,lib_lib_fatal "first argument is empty"; fi

if [[ "${1:-}" = '--bash-completion' ]]; then
	,lib_lib_bash_completion
	return
	exit
fi
if (($# == 0)); then
	,lib_lib_their_usage "$@"
	exit
fi

L_mode=$1
shift
if ! L_function_exists "$L_prefix$L_mode"; then
	,lib_lib_their_usage
	,lib_lib_error "Unknown command: $L_mode"
	,lib_lib_show_best_match "$L_mode"
	exit
fi
"$L_prefix$L_mode" "$@"

# }}}

# vim: foldmethod=marker:nofoldenable

