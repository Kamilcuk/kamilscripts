#!/usr/bin/python3

import argparse
import atexit
import logging
import os
import pwd
import shlex
import signal
import socket
import subprocess
import sys
import threading
import time
import traceback
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path
from typing import IO, List

ON_POSIX = "posix" in sys.builtin_module_names
HOSTNAME = socket.gethostname()
log = logging.getLogger(__name__)


def quotearr(cmd: List[str]):
    return " ".join(shlex.quote(x) for x in cmd)


###############################################################################


class Waiter(ABC):
    def __init__(self):
        log.debug(f"Initializing {self.__class__.__name__}")

    @abstractmethod
    def wait(self):
        raise NotImplementedError()


def readbytelines(input: IO[bytes], separator=b"\0", readSize=1):
    partialLine = b""
    while True:
        charsJustRead = input.read(readSize)
        if not charsJustRead:
            break
        partialLine += charsJustRead
        lines = partialLine.split(separator)
        partialLine = lines.pop()
        for line in lines:
            yield line.decode()
    if partialLine:
        yield partialLine.decode()


def is_relative_to(a: Path, b: Path):
    try:
        a.relative_to(b)
        return True
    except ValueError:
        return False


class Inotify(Waiter):
    def __init__(self, paths: List[Path]):
        self.lock = threading.Lock()
        self.paths = paths
        # cmd = "inotifywait -qme close_write,moved_to --format %f".split()
        cmd = "inotifywait -qme create,modify,close_write,moved_to --format %w%f%0 --no-newline".split()
        cmd += [str(p.parent if p.is_file() else p) for p in self.paths]
        log.debug(f"+ {cmd}")
        self.proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        self.thread = threading.Thread(
            target=Inotify.enqueue_output, args=[self], daemon=True
        )
        self.lock.acquire()
        self.thread.start()

    def enqueue_output(self):
        assert self.proc.stdout
        for line in readbytelines(self.proc.stdout, b"\0"):
            line = Path(line)
            for path in self.paths:
                if path.is_file():
                    if line == path:
                        log.debug(f"{line} is {path}, signaling")
                        self.signal()
                        break
                elif is_relative_to(line, path):
                    log.debug(f"{line} is relative to {path}, signaling")
                    self.signal()
                    break
            else:
                log.debug(f"Received {line} but not matched against {self.paths}")
        self.proc.stdout.close()

    def signal(self):
        try:
            self.lock.release()
        except RuntimeError:
            pass

    def wait(self):
        self.lock.acquire()


class Poller(Waiter):
    def __init__(self, paths: List[Path]):
        self.paths = paths
        self.lastchanged = self.changehash()

    def changehash(self):
        files = [
            y
            for x in self.paths
            for y in ([x] if x.is_file() else x.rglob("*"))
            if y.is_file()
        ]
        return set(os.path.getmtime(file) for file in files)

    def wait(self):
        while True:
            time.sleep(1)
            changed = self.changehash()
            if self.lastchanged != changed:
                self.lastchanged = changed
                return


###############################################################################


class Runner(ABC):
    def __init__(self, cmd: List[str]):
        log.debug(f"Initializing {self.__class__.__name__}")
        self.cmd = cmd
        self.cmdstr = quotearr(cmd)

    def clear(self):
        os.system("cls" if os.name == "nt" else "clear")

    def print_left_right(self, left, right):
        termsize = os.get_terminal_size()
        columns = termsize.columns
        rightlen = len(right)
        leftlen = len(left)
        if rightlen > columns / 2:
            right = ""
            rightlen = 0
        if leftlen + rightlen > columns - 2:
            left = left[0 : columns - 5 - rightlen] + "..."
            leftlen = len(left)
        print("%s%*s" % (left, columns - leftlen, right))

    def event(self):
        if not args.debug:
            self.clear()
        if not args.no_title:
            self.print_left_right(
                "Every %s change: %s" % (args.cmd[0], self.cmdstr),
                "%s: %s" % (HOSTNAME, datetime.now().strftime("%c")),
            )
        print("+", self.cmdstr)
        self.run()

    @abstractmethod
    def run(self):
        raise NotImplementedError()


class ShellRunner(Runner):
    def __init__(self, cmd: List[str]):
        shell = pwd.getpwuid(os.getuid()).pw_shell
        super().__init__([shell, "-c", " ".join(cmd)])

    def run(self):
        subprocess.run(self.cmd)


class ExecRunner(Runner):
    def run(self):
        subprocess.run(self.cmd)


class PythonRunner(Runner):
    def __init__(self, cmd: List[str]):
        super().__init__(["python3shell", *cmd])

    def run(self):
        sys.argv = args.cmd
        try:
            exec(open(args.cmd[0], "r").read())
        except Exception:
            traceback.print_exc()


def killonexit():
    os.killpg(os.getpgid(0), signal.SIGTERM)


def parse_args():
    parser = argparse.ArgumentParser(
        description="Each time the file changes, run the command displaying its output.",
        epilog="Written by Kamil Cukrowski. 2022",
    )
    parser.add_argument(
        "-t",
        "--no-title",
        action="store_true",
        help="Turn off showing the header and the following blank line.",
    )
    parser.add_argument(
        "-b", "--beep", action="store_true", help="Beep if command has a non-zero exit."
    )
    parser.add_argument(
        "-k",
        "--killonchange",
        action="store_true",
        help="Kill the current process if file changes.",
    )
    parser.add_argument(
        "-d",
        "--differences",
        action="store_true",
        help="highlight changes between updates",
    )
    parser.add_argument(
        "-p", "--python", action="store_true", help="run python script in same process"
    )
    parser.add_argument(
        "-x",
        "--exec",
        action="store_true",
        help='pass command to exec instead of "sh -c"',
    )
    parser.add_argument(
        "-f",
        "--file",
        help="watch this file or dir for changes. The first argument starts the command.",
        action="append",
        default=[],
        type=Path,
    )
    parser.add_argument(
        "-D",
        "--debug",
        action="store_true",
    )
    parser.add_argument(
        "-S",
        "--poll",
        action="store_true",
        help="Use polling method instead of inoitfywait",
    )
    parser.add_argument("path")
    parser.add_argument("cmd", nargs=argparse.REMAINDER)
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO)
    atexit.register(killonexit)
    #
    if args.file:
        paths = args.file
        cmd = [args.path, *args.cmd]
    else:
        paths = [Path(args.path)]
        cmd = args.cmd
    log.debug(f"cmd = {cmd}")
    log.debug(f"paths = {paths}")
    assert cmd
    for i in paths:
        assert i.exists(), f"{i} does not exists"
    #
    waiter = None
    if not args.poll:
        try:
            waiter = Inotify(paths)
        except FileNotFoundError:
            log.debug("inotifywait was not found, using polling method")
    if waiter is None:
        waiter = Poller(paths)
    #
    if args.python:
        assert not args.exec
        rr = PythonRunner(cmd)
    elif args.exec:
        rr = ExecRunner(cmd)
    else:
        rr = ShellRunner(cmd)
    #
    try:
        while True:
            rr.event()
            waiter.wait()
    except KeyboardInterrupt:
        pass
