#!/usr/bin/python3

import argparse
import atexit
import logging
import os
import queue
import shlex
import signal
import socket
import subprocess
import sys
import time
import traceback
from datetime import datetime

import kc

ON_POSIX = "posix" in sys.builtin_module_names
HOSTNAME = socket.gethostname()
log = logging.getLogger(__name__)


class Waiter:
    def getOneFlush(self):
        raise NotImplementedError()


class Inotify(Waiter):
    q = queue.Queue()

    def __init__(self):
        from threading import Thread

        self.dir = os.path.dirname(args.file)
        self.filename = os.path.basename(args.file)
        cmd = "inotifywait -qme close_write,moved_to --format %f".split() + [self.dir]
        log.debug(cmd)
        self.proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            text=True,
        )
        self.thread = Thread(target=Inotify.enqueue_output, args=[self])
        self.thread.demon = True
        log.debug("Thread started")
        self.thread.start()

    def enqueue_output(self):
        for line in self.proc.stdout:
            line = line[:-1]
            if line == self.filename:
                log.debug("Received and put: %s %s", line, self.filename)
                self.q.put(line)
            else:
                log.debug("Received: %s %s", line, self.filename)
        self.proc.stdout.close()

    def getOneFlush(self):
        if not self.q.empty():
            try:
                while self.q.get_nowait():
                    pass
            except queue.EMPTY:
                pass
        else:
            self.q.get()


class Sleeper(Waiter):
    def changed(self):
        return os.path.getmtime(args.file)

    def __init__(self):
        self.lastchanged = self.changed()

    def getOneFlush(self):
        while True:
            time.sleep(1)
            changed = self.changed()
            if self.lastchanged != changed:
                self.lastchanged = changed
                return


def parse_args():
    parser = argparse.ArgumentParser(
        description="Each time the file changes, run the command displaying its output.",
        epilog="Written by Kamil Cukrowski. 2022",
    )
    parser.add_argument(
        "-t",
        "--no-title",
        action="store_true",
        help="Turn off showing the header and the following blank line.",
    )
    parser.add_argument(
        "-b", "--beep", action="store_true", help="Beep if command has a non-zero exit."
    )
    parser.add_argument(
        "-k",
        "--killonchange",
        action="store_true",
        help="Kill the current process if file changes.",
    )
    parser.add_argument(
        "-d",
        "--differences",
        action="store_true",
        help="highlight changes between updates",
    )
    parser.add_argument(
        "-p", "--python", action="store_true", help="run python script in same process"
    )
    parser.add_argument(
        "-x",
        "--exec",
        action="store_true",
        help='pass command to exec instead of "sh -c"',
    )
    parser.add_argument(
        "-f",
        "--file",
        help="watch this file instead of first argument",
    )
    parser.add_argument(
        "-D",
        "--debug",
        action="store_true",
    )
    parser.add_argument(
        "-S",
        "--poll",
        action="store_true",
        help="Use polling method instead of inoitfywait",
    )
    parser.add_argument("cmd", nargs=1)
    parser.add_argument("args", nargs=argparse.REMAINDER)
    return parser.parse_args()


class Runner:
    def __init__(self, cmdstr):
        self.cmdstr = cmdstr

    def clear(sefl):
        os.system("cls" if os.name == "nt" else "clear")

    def print_left_right(self, left, right):
        termsize = os.get_terminal_size()
        columns = termsize.columns
        rightlen = len(right)
        leftlen = len(left)
        if rightlen > columns / 2:
            right = ""
            rightlen = 0
        if leftlen + rightlen > columns - 2:
            left = left[0 : columns - 5 - rightlen] + "..."
            leftlen = len(left)
        print("%s%*s" % (left, columns - leftlen, right))

    def run(self):
        raise NotImplementedError()

    def event(self):
        if not args.debug:
            self.clear()
        if not args.no_title:
            self.print_left_right(
                "Every %s change: %s" % (args.cmd[0], self.cmdstr),
                "%s: %s" % (HOSTNAME, datetime.now().strftime("%c")),
            )
        print("+", self.cmdstr)
        self.run()


class ShellRunner(Runner):
    def __init__(self):
        super().__init__(kc.shlex_join(args.cmd))

    def run(self):
        subprocess.run(args.cmd)


class PythonRunner(Runner):
    def __init__(self):
        super().__init__(kc.shlex_join(["python3shell"] + args.cmd))

    def run(self):
        sys.argv = args.cmd
        try:
            exec(open(args.cmd[0], "r").read())
        except Exception:
            traceback.print_exc()


def killonexit():
    os.killpg(os.getpgid(0), signal.SIGTERM)


if __name__ == "__main__":
    args = parse_args()
    logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO)
    atexit.register(killonexit)
    args.cmd = args.cmd + (args.args or [])
    #
    if not args.exec and not args.python:
        if not args.file:
            exit("--file argument is required when not using --python nor --exec")
        args.cmd = ["sh", "-c", kc.shlex_join(args.cmd)]
    elif not args.file:
        if "/" not in args.cmd[0]:
            if os.path.exists(args.cmd[0]):
                args.cmd[0] = "./" + args.cmd[0]
            else:
                from shutil import which

                args.cmd[0] = which(args.cmd[0])
        args.file = args.cmd[0]
    waiter = None
    if not args.poll:
        try:
            waiter = Inotify()
        except FileNotFoundError:
            # If inotifywait was not found, use polling method.
            pass
    if waiter is None:
        waiter = Sleeper()
    #
    if args.python:
        rr = PythonRunner()
    else:
        rr = ShellRunner()
    #
    while True:
        rr.event()
        waiter.getOneFlush()
